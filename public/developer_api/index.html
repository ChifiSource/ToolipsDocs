<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>extending toolips · toolips</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="toolips logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">toolips</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">toolips</a></li><li><span class="tocitem">basics</span><ul><li><a class="tocitem" href="../projects/">projects</a></li><li><a class="tocitem" href="../interface/">servables</a></li><li><a class="tocitem" href="../core/">core</a></li></ul></li><li><span class="tocitem">advanced</span><ul><li><a class="tocitem" href="../toolips_session/">session extension</a></li><li><a class="tocitem" href="../creating_servables/">creating servables</a></li><li class="is-active"><a class="tocitem" href>extending toolips</a><ul class="internal"><li><a class="tocitem" href="#creating-connection-extensions"><span>creating connection extensions</span></a></li><li><a class="tocitem" href="#creating-server-extensions"><span>creating server extensions</span></a></li><li><a class="tocitem" href="#toolips-internals"><span>toolips internals</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">advanced</a></li><li class="is-active"><a href>extending toolips</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>extending toolips</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChifiSource/Toolips.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="creating-extensions"><a class="docs-heading-anchor" href="#creating-extensions">creating extensions</a><a id="creating-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#creating-extensions" title="Permalink"></a></h1><p>There are both Connection and Server extensions. Here is how to make them.</p><h2 id="creating-connection-extensions"><a class="docs-heading-anchor" href="#creating-connection-extensions">creating connection extensions</a><a id="creating-connection-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#creating-connection-extensions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.AbstractConnection" href="#Toolips.AbstractConnection"><code>Toolips.AbstractConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type AbstractConnection</strong></p><p>Connections are passed through function routes and can have Servables written     to it.</p><p><strong>Consistencies</strong></p><ul><li>routes::Dict - A {String, Function} dictionary that the server references to</li></ul><p>direct incoming connections.</p><ul><li>http::Any - Usually an HTTP.Stream, however can be anything that is binded to</li></ul><p>the Base.write method.</p><ul><li>extensions::Dict - A {Symbol, ServerExtension} dictionary that can be used to</li></ul><p>access ServerExtensions.</p></div></section></article><p>Abstract Connections must have the extensions Dict, the routing Dict, and some sort of writable stream called http. This needs to be binded to Base.write. A good example of this is Toolips.SpoofStream and Toolips.SpoofConnection, which can be used to write connection output to a string.</p><pre><code class="language-julia hljs">mutable struct SpoofStream
    text::String
    SpoofStream() = new(&quot;&quot;)
end</code></pre><p>The http value can be anything, so in this case it will be a SpoofStream. The SpoofStream contains only a string, text. This is then binded to the write method:</p><pre><code class="language-julia hljs">write(s::SpoofStream, e::Any) = s.text = s.text * string(e)
write(c::SpoofStream, s::Servable) = s.f(c)</code></pre><p>Finally, we make our connection, using SpoofStream as HTTP.</p><pre><code class="nohighlight hljs">mutable struct SpoofConnection &lt;: AbstractConnection
    routes::Dict
    http::SpoofStream
    extensions::Dict
    function SpoofConnection(r::Dict, http::SpoofStream, extensions::Dict)
        new(r, SpoofStream(), extensions)
    end
    SpoofConnection() = new(Dict(), SpoofStream(), Dict())
end</code></pre><h2 id="creating-server-extensions"><a class="docs-heading-anchor" href="#creating-server-extensions">creating server extensions</a><a id="creating-server-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#creating-server-extensions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.ServerExtension" href="#Toolips.ServerExtension"><code>Toolips.ServerExtension</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type ServerExtension</strong></p><p>Server extensions are loaded into the server on startup, and can have a few different abilities according to their type field&#39;s value. This value can be either a Symbol or a Vector of Symbols.</p><p><strong>Consistencies</strong></p><ul><li>type::T where T == Vector{Symbol}  || T == Symbol. The type can be :routing,</li></ul><p>:func, :connection, or any combination inside of a Vector{Symbol}. :routing ServerExtensions must have an f() function that takes two dictionaries; e.g. f(r::Dict{String, Function}, e::Dict{Symbol, ServerExtension}) The first Dict is the dictionary of routes, the second is the dictionary of server extensions. :func server extensions will be ran everytime the server is routed. They will need to have the same f function, but taking a single argument as a connection.     Lastly, :connection extensions are simply pushed to the connection.</p></div></section></article><p>Server extensions are a little bit more intense. There are three types of server extensions, <strong>:func, :routing, and :connection.</strong> The type field can be either a Vector{Symbol}, or a single symbol – and a combination of each of these can be written. A :func extension is one that holds a function that is ran every time a Connection is routed. A :func extension requires that the function f(::AbstractConnection) or f(::Connection) exists inside of it. Here is an example:</p><pre><code class="language-julia hljs">import Toolips: ServerExtension

mutable struct MyExtension &lt;: ServerExtension
    f::Function
    function MyExtension()
        f(c::Connection) = begin
            write!(c, &quot;Hello!&quot;)
        end
    end
end</code></pre><p>Each time the server is routed, there will now be &quot;Hello!&quot; written to the top of the page. A :routing extension is similar, but we will want to have the f function instead take two dictionaries. The dictionaries are specifically of type Dict{String, Function}, and Dict{Symbol, ServerExtension}. A great example of this is the Toolips.Files extension:</p><pre><code class="language-julia hljs">mutable struct Files &lt;: ServerExtension
    type::Symbol
    directory::String
    f::Function
    function Files(directory::String = &quot;public&quot;)
        f(r::Dict, e::Dict) = begin
            l = length(directory) + 1
            for path in route_from_dir(directory)
                push!(r, path[l:length(path)] =&gt; c::Connection -&gt; write!(c, File(path)))
            end
        end
        new(:routing, directory, f)
    end
end</code></pre><p>Finally, there is also a :connection extension. These are extensions that are to be pushed into the Connection&#39;s extensions field. Nothing extra needs to be done to these types of extensions. A great example of this is the Toolips.Logger:</p><pre><code class="language-julia hljs">mutable struct Logger &lt;: ServerExtension
    type::Symbol
    out::String
    levels::Dict
    log::Function
    prefix::String
    timeformat::String
    writeat::Int64
    function Logger(levels::Dict{Any, Crayon} = Dict(
    1 =&gt; Crayon(foreground = :light_cyan),
    2 =&gt; Crayon(foreground = :light_yellow),
    3 =&gt; Crayon(foreground = :yellow, bold = true),
    4 =&gt; Crayon(foreground = :red, bold = true),
    :time_crayon =&gt; Crayon(foreground = :magenta, bold = true),
     :message_crayon =&gt; Crayon(foreground  = :light_blue, bold = true)
    );
    out::String = pwd() * &quot;/logs/log.txt&quot;, prefix::String = &quot;🌷 toolips&gt; &quot;,
                    timeformat::String = &quot;YYYY:mm:dd:HH:MM&quot;, writeat::Int64 = 2)

        log(level::Int64, message::String) = _log(level, message, levels, out,
                                                prefix, timeformat, writeat)
        log(message::String) = _log(1, message, levels, out, prefix, timeformat,
        writeat)
        log(c::Connection, message::String) = _log(c, message)
        # These bindings are left open-ended for extending via
                                            # import Toolips._log
        log(level::Int64, message::Any) = _log(level, a, levels, out, prefix,
                                            timeformat)
        new(:connection, out::String, levels::Dict, log::Function,
                    prefix::String, timeformat::String, writeat::Int64)::Logger
    end
end</code></pre><h2 id="toolips-internals"><a class="docs-heading-anchor" href="#toolips-internals">toolips internals</a><a id="toolips-internals-1"></a><a class="docs-heading-anchor-permalink" href="#toolips-internals" title="Permalink"></a></h2><p>If you&#39;re looking at the internals, you are probably good enough at reading documentation... Here are the doc-strings, my friend. <strong>Thank you</strong> for contributing.</p><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{SpoofStream, Any}" href="#Base.write-Tuple{SpoofStream, Any}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Internals</strong></p><p><strong>write(s::SpoofStream, e::Any) -&gt; _</strong></p><hr/><p>A binding to Base.write that allows one to write to SpoofStream.text.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">s = SpoofStream()
write(s, &quot;hi&quot;)
println(s.text)
    hi</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{SpoofStream, Servable}" href="#Base.write-Tuple{SpoofStream, Servable}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Internals</strong></p><p><strong>write(s::SpoofStream, e::Servable) -&gt; _</strong></p><hr/><p>A binding to Base.write that allows one to write a Servable to SpoofStream.text.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">s = SpoofStream()
write(s, p(&quot;hello&quot;))
println(s.text)
    &lt;p id = &quot;hello&quot;&gt;&lt;/p&gt;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.create_serverdeps" href="#Toolips.create_serverdeps"><code>Toolips.create_serverdeps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Internals</strong></p><p><strong>create_serverdeps(name::String, inc::String) -&gt; _</strong></p><hr/><p>Creates the essential portions of the webapp file structure, where name is the project&#39;s name and inc is any extensions or strings to incorporate at the top of the file.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">create_serverdeps(&quot;ToolipsApp&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.serverfuncdefs" href="#Toolips.serverfuncdefs"><code>Toolips.serverfuncdefs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core</strong></p><p><strong>serverfuncdefs(::AbstractVector, ::String, ::Integer,</strong></p><p><strong>::Dict) -&gt; (::Function, ::Function, ::Function)</strong></p><p>This method is used internally by a constructor to generate the functions add, start, and remove for the ServerTemplate.</p><p><strong>example</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips._start" href="#Toolips._start"><code>Toolips._start</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core - Internals</strong></p><p><strong>_start(routes::AbstractVector, ip::String, port::Integer,</strong></p><p><strong>extensions::Dict, c::Type) -&gt; ::WebServer</strong></p><p>This is an internal function for the ServerTemplate. This function is binded to     the ServerTemplate.start field.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">st = ServerTemplate()
st.start()</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.generate_router" href="#Toolips.generate_router"><code>Toolips.generate_router</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Core - Internals</strong></p><p><strong>generate_router(routes::AbstractVector, server::Any, extensions::Dict,</strong></p><pre><code class="nohighlight hljs">        conn::Type)</code></pre><hr/><p>This method is used internally by the <strong>_start</strong> method. It returns a closure function that both routes and calls functions.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">server = Sockets.listen(Sockets.InetAddr(parse(IPAddr, ip), port))
if has_extension(extensions, Logger)
    extensions[Logger].log(1,
     &quot;Toolips Server starting on port &quot; * string(port))
end
routefunc, rdct, extensions = generate_router(routes, server, extensions,
                                                Connection)
@async HTTP.listen(routefunc, ip, port, server = server)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips._log" href="#Toolips._log"><code>Toolips._log</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Extensions</strong></p><p><strong>_log(level::Int64, message::String, levels::Dict, out::String) -&gt; _</strong></p><hr/><p>Binded call for the field log() inside of Logger(). See ?(Logger) for more     details on the field log. All arguments are fields of that type. Return is a     printout into the REPL as well as an append to the log file, provided by the     out URI. –––––––––</p><p><strong>example (Closure from Logger)</strong></p><pre><code class="nohighlight hljs">log(level::Int64, message::String) = _log(level, message, levels, out)
log(message::String) = _log(1, message, levels, out)</code></pre></div></section><section><div><p><strong>Extensions</strong></p><p><strong>_log(http::HTTP.Stream, message::String) -&gt; _</strong></p><hr/><p>Binded call for the field log() inside of Logger(). This will log both to the     JavaScript/HTML console. –––––––––</p><p><strong>example (Closure from Logger)</strong></p><pre><code class="nohighlight hljs">log(http::HTTP.Stream, message::String) = _log(http, message)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string" href="#Base.string"><code>Base.string</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Internals</strong></p><p><strong>string(r::Vector{UInt8}) -&gt; ::String</strong></p><hr/><p>Turns a vector of UInt8s into a string.</p></div></section><section><div><p><strong>Interface</strong></p><p><strong>string(c::Component) -&gt; ::String</strong></p><hr/><p>Shows c as a string representation of itself.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c = divider(&quot;example&quot;, align = &quot;center&quot;)
string(c)
    &quot;divider: align = center&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.SpoofConnection" href="#Toolips.SpoofConnection"><code>Toolips.SpoofConnection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SpoofConnection &lt;: AbstractConnection</strong></p><ul><li>routes::Dict</li><li>http::SpoofStream</li><li>extensions::Dict -</li></ul><p>Builds a fake connection with a SpoofStream. Useful if you want to write a Servable without a server.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">fakec = SpoofConnection()
servable = Component()
# write!(::AbstractConnection, ::Servable):
write!(fakec, servable)</code></pre><hr/><p><strong>field info</strong></p><ul><li>routes::Dict - A dictionary of routes, usually left empty.</li><li>http::SpoofStream - A fake http stream that instead writes output to a string.</li><li>extensions::Dict - A dictionary of extensions, usually empty.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>SpoofStream(r::Dict, http::SpoofStream, extensions::Dict)</li><li>SpoofStream()</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.SpoofStream" href="#Toolips.SpoofStream"><code>Toolips.SpoofStream</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SpoofStream</strong></p><ul><li>text::String</li></ul><p>The SpoofStream allows us to fake a connection by building a SpoofConnection which will write to the SpoofStream.text field whenever write! is called. This is useful for testing, or just writing servables into a string.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">stream = SpoofStream()
write(stream, &quot;hello!&quot;)
println(stream.text)

    hello!
conn = SpoofConnection()
servab = Component()
write!(conn, servab)</code></pre><hr/><p><strong>field info</strong></p><ul><li>text::String - The text written to the stream.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>SpoofStream()</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route_from_dir" href="#Toolips.route_from_dir"><code>Toolips.route_from_dir</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Extensions</strong></p><p><strong>route<em>from</em>dir(dir::String) -&gt; ::Vector{String}</strong></p><hr/><p><strong>Recursively appends filenames for a directory AND all subsequent directories.</strong></p><p><strong>example</strong></p><pre><code class="nohighlight hljs">x::Vector{String} = route_from_dir(&quot;mypath&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{Base.TTY, Component}" href="#Base.show-Tuple{Base.TTY, Component}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>show(t::Base.TTY, x::Component) -&gt; _</strong></p><hr/><p>Shows a component as markdown in a terminal.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs"># In the terminal, elsewhere the component will show as HTML.
show(x)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{Component}" href="#Base.show-Tuple{Component}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>show(x::Component) -&gt; _</strong></p><hr/><p>Shows a component as HTML.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">show(x)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.show_log" href="#Toolips.show_log"><code>Toolips.show_log</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Extensions</strong></p><p><strong>show_log(level::Int64, message::String, levels::Dict{Any, Crayon},</strong></p><pre><code class="nohighlight hljs">            prefix::String, time::Any)</code></pre><hr/><p>Prints a log to the screen.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">show_log(1, &quot;hello!&quot;, levels, &quot;toolips&gt; &quot;, now()

[2022:05:23:22:01] toolips&gt; hello!</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.@L_str" href="#Toolips.@L_str"><code>Toolips.@L_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><strong>Interface</strong></p><p><strong>L_str(s::String) -&gt; ::String</strong></p><hr/><p>Creates a literal string</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">x = 5
L&quot;dollar_signx&quot; # pretend dollar_sign is a dollar sign.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.has_extension-Tuple{Dict, Type}" href="#Toolips.has_extension-Tuple{Dict, Type}"><code>Toolips.has_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Internals</strong></p><p><strong>has_extension(d::Dict, t::Type) -&gt; ::Bool</strong></p><hr/><p>Checks if d has an extension of type t.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">if has_extension(d, Logger)
    d[:Logger].log(&quot;it has a logger, I think.&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.argsplit" href="#Toolips.argsplit"><code>Toolips.argsplit</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Internals</strong></p><p><strong>argsplit(args::Vector{AbstractString}) -&gt; ::Dict{Symbol, Any}</strong></p><hr/><p>Used by the getargs method to parse GET arguments into a Dict.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">argsplit([&quot;c=5&quot;, &quot;b=8&quot;])
    Dict(:c =&gt; 5, :b =&gt; 8)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple{Vector{UInt8}}" href="#Base.string-Tuple{Vector{UInt8}}"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Internals</strong></p><p><strong>string(r::Vector{UInt8}) -&gt; ::String</strong></p><hr/><p>Turns a vector of UInt8s into a string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.showchildren" href="#Toolips.showchildren"><code>Toolips.showchildren</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Internals</strong></p><p><strong>showchildren(x::Component) -&gt; ::String</strong></p><hr/><p>Get the children of x as a markdown string.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c = divider(&quot;example&quot;)
child = p(&quot;mychild&quot;)
push!(c, child)
s = showchildren(c)
println(s)
&quot;##### children
|-- mychild</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../creating_servables/">« creating servables</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 30 June 2022 00:52">Thursday 30 June 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
