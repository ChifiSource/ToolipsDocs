<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>core · toolips</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="toolips logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">toolips</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">toolips</a></li><li><span class="tocitem">basics</span><ul><li><a class="tocitem" href="../projects/">projects</a></li><li><a class="tocitem" href="../interface/">servables</a></li><li class="is-active"><a class="tocitem" href>core</a><ul class="internal"><li><a class="tocitem" href="#connection"><span>connection</span></a></li><li><a class="tocitem" href="#routing"><span>routing</span></a></li><li><a class="tocitem" href="#servers"><span>servers</span></a></li><li><a class="tocitem" href="#server-extensions"><span>server extensions</span></a></li></ul></li></ul></li><li><span class="tocitem">advanced</span><ul><li><a class="tocitem" href="../toolips_session/">session extension</a></li><li><a class="tocitem" href="../creating_servables/">creating servables</a></li><li><a class="tocitem" href="../developer_api/">extending toolips</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">basics</a></li><li class="is-active"><a href>core</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>core</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChifiSource/Toolips.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="core"><a class="docs-heading-anchor" href="#core">core</a><a id="core-1"></a><a class="docs-heading-anchor-permalink" href="#core" title="Permalink"></a></h1><p>Below is a runthrough of all of the documentation pertaining to running a Toolips server.</p><h2 id="connection"><a class="docs-heading-anchor" href="#connection">connection</a><a id="connection-1"></a><a class="docs-heading-anchor-permalink" href="#connection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Toolips.Connection" href="#Toolips.Connection"><code>Toolips.Connection</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Connection &lt;: AbstractConnection</strong></p><ul><li>routes::Dict</li><li>http::HTTP.Stream</li><li>extensions::Dict</li></ul><p>The connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">                  #  v The Connection
home = route(&quot;/&quot;) do c::Connection
    c[Logger].log(1, &quot;We can index extensions by type or symbol&quot;)
    c[:logger].log(1, &quot;see?&quot;)
    c.routes[&quot;/&quot;] = c::Connection -&gt; write!(c, &quot;rerouting!&quot;)
    httpstream = c.http
    write!(c, &quot;Hello world!&quot;)
    myheading::Component = h(&quot;myheading&quot;, 1, text = &quot;Whoa!&quot;)
    write!(c, myheading)
end</code></pre><hr/><p><strong>field info</strong></p><ul><li><strong>routes::Dict</strong> - A dictionary of routes where the keys</li></ul><p>are the routed URL and the values are the functions to those keys.</p><ul><li><strong>http::HTTP.Stream</strong> - The stream for this current peer&#39;s connection.</li><li><strong>extensions::Dict</strong> - A dictionary of extensions to load with the</li></ul><p><strong>name to reference as keys and the extension as the pair.</strong></p><p><strong>constructors</strong></p><ul><li>Connection(routes::Dict, http::HTTP.Stream, extensions::Dict)</li></ul></div></section></article><p>Connections are served as an argument to incoming routes. Functions are written anticipating a connection return. Here we will write a new route using the route(::Function, ::String) method.</p>Route(&quot;/&quot;, Main.EvalBlockSandbox.var&quot;#1#2&quot;())<p>We also use the write!() method on our Connection. We can use this on the types ::Any, ::Vector{Servable}, and ::Servable.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!" href="#Toolips.write!"><code>Toolips.write!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Servable) -&gt; _</strong></p><hr/><p>Writes a Servable&#39;s return to a Connection&#39;s stream. This is usually used in a routing function or a route where ::Connection is provided as an argument.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">serv = p(&quot;mycomp&quot;, text = &quot;hello&quot;)

rt = route(&quot;/&quot;) do c::Connection
    write!(c, serv)
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Vector{Servable}) -&gt; _</strong></p><hr/><p>Writes all servables in s to c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c = Component()
c2 = Component()
comps = components(c, c2)
    Vector{Servable}(Component(), Component())

write!(c, comps)</code></pre></div></section><section><div></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::String) -&gt; _</strong></p><hr/><p>Writes the String into the Connection as HTML.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">write!(c, &quot;hello world!&quot;)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(::AbstractConnection, ::Any) -&gt; _</strong></p><hr/><p>Attempts to write any type to the Connection&#39;s stream.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">d = 50
write!(c, d)</code></pre></div></section></article><p>Or push any data response into a body and startread the body.</p><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Tuple{AbstractConnection, Any}" href="#Base.push!-Tuple{AbstractConnection, Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>push!(c::AbstractConnection, data::Any) -&gt; _</strong></p><hr/><p>A &quot;catch-all&quot; for pushing data to a stream. Produces a full response with <strong>data</strong> as the body.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs"></code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.startread!-Tuple{AbstractConnection}" href="#Toolips.startread!-Tuple{AbstractConnection}"><code>Toolips.startread!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>startread!(::AbstractConnection) -&gt; _</strong></p><hr/><p>Resets the seek on the Connection. This function is only meant to be used on post bodies.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">post = getpost(c)
    &quot;hello&quot;
post = getpost(c)
    &quot;&quot;
startread!(c)
post = getpost(c)
    &quot;hello&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.extensions-Tuple{Connection}" href="#Toolips.extensions-Tuple{Connection}"><code>Toolips.extensions</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>extensions(c::Connection) -&gt; ::Dict{Symbol, ServerExtension}</strong></p><hr/><p>Returns the server&#39;s extensions.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    extensions(c)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes-Tuple{AbstractConnection}" href="#Toolips.routes-Tuple{AbstractConnection}"><code>Toolips.routes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(c::Connection) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    routes(c)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.has_extension-Tuple{AbstractConnection, Type}" href="#Toolips.has_extension-Tuple{AbstractConnection, Type}"><code>Toolips.has_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>has_extension(c::AbstractConnection, t::Type) -&gt; ::Bool</strong></p><hr/><p>Checks if c.extensions has an extension of type t.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">if has_extension(c, Logger)
    c[:Logger].log(&quot;it has a logger, I think.&quot;)
end</code></pre></div></section></article><p>The connection type can be indexed with Symbols, Strings, and Types. Symbols and Types will index the extensions. Strings will index the routes. The same goes for setting the indexes.</p><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractConnection, Function, String}" href="#Base.setindex!-Tuple{AbstractConnection, Function, String}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>setindex!(c::AbstractConnection, f::Function, s::String) -&gt; _</strong></p><hr/><p>Sets the route path s to serve at the function f.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c[&quot;/&quot;] = c -&gt; write!(c, &quot;hello&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, Symbol}" href="#Base.getindex-Tuple{AbstractConnection, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(c::AbstractConnection, s::Symbol) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    c[:Logger].log(&quot;hi&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, Type}" href="#Base.getindex-Tuple{AbstractConnection, Type}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(c::AbstractConnection, t::Type) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in c by type.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    c[Logger].log(&quot;hi&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, String}" href="#Base.getindex-Tuple{AbstractConnection, String}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(c::AbstractConnection, s::String) -&gt; ::Function</strong></p><hr/><p>Returns the function that corresponds to the route dir s.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c[&quot;/&quot;]

    home</code></pre></div></section></article><p>We also use the Connection in order to get arguments, download files, and pretty much anything else pertaining to a person&#39;s connection.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.getarg" href="#Toolips.getarg"><code>Toolips.getarg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getarg(c::AbstractConnection, s::Symbol) -&gt; ::Any</strong></p><hr/><p>Returns the requested argument from the target.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getarg(c, :x)
    50</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>getarg(c::AbstractConnection, s::Symbol, t::Type) -&gt; ::Vector</strong></p><hr/><p>This method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that &quot;Cannot convert...&quot; errors are possible with this method.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getarg(c, :x, Int64)
    50</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getargs" href="#Toolips.getargs"><code>Toolips.getargs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getargs(c::AbstractConnection) -&gt; ::Dict{Symbol, Any}</strong></p><hr/><p>The getargs method returns arguments from the HTTP target (GET requests.) Returns a Dict with the argument keys as Symbols.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c
    args = getargs(c)
    args[:message]
        &quot;welcome to toolips ! :)&quot;
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getip" href="#Toolips.getip"><code>Toolips.getip</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getip(c::AbstractConnection) -&gt; ::String</strong></p><hr/><p>Returns the IP that is connected via the connection c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getip(c)
&quot;127.0.0.2&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getpost" href="#Toolips.getpost"><code>Toolips.getpost</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getpost(c::AbstractConnection) -&gt; ::String</strong></p><hr/><p>Returns the POST body of c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getpost(c)
&quot;hello, this is a post request&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.download!" href="#Toolips.download!"><code>Toolips.download!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>download!(c::AbstractConnection, uri::String) -&gt; _</strong></p><hr/><p>Downloads a file to a given Connection&#39;s computer.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">download!(c, &quot;files/mytext.txt&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.navigate!" href="#Toolips.navigate!"><code>Toolips.navigate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>navigate!(::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Routes a connected stream to a given URL.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">navigate!(c, &quot;https://github.com/ChifiSource/Toolips.jl&quot;)</code></pre></div></section></article><p>We can also check if an extension is present by type.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.has_extension-Tuple{Connection, Type}" href="#Toolips.has_extension-Tuple{Connection, Type}"><code>Toolips.has_extension</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>has_extension(c::AbstractConnection, t::Type) -&gt; ::Bool</strong></p><hr/><p>Checks if c.extensions has an extension of type t.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">if has_extension(c, Logger)
    c[:Logger].log(&quot;it has a logger, I think.&quot;)
end</code></pre></div></section></article><h2 id="routing"><a class="docs-heading-anchor" href="#routing">routing</a><a id="routing-1"></a><a class="docs-heading-anchor-permalink" href="#routing" title="Permalink"></a></h2><p>When routing, many methods involve the <strong>Connection</strong> type we just spoke of. In toolips, routes are handled by the Route type.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.Route" href="#Toolips.Route"><code>Toolips.Route</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Route</strong></p><ul><li>path::String</li><li>page::Function A route is added to a ServerTemplate using either its constructor, or the</li></ul><p>ServerTemplate.add(::Route) method. Each route calls a function. The Route type is commonly constructed using the do syntax with the route(::Function, ::String) method.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs"># Constructors
route = Route(&quot;/&quot;, p(text = &quot;hello&quot;))

function example(c::Connection)
    write!(c, &quot;hello&quot;)
end

route = Route(&quot;/&quot;, example)

# method
route = route(&quot;/&quot;) do c
    write!(c, &quot;Hello world!&quot;)
    write!(c, p(text = &quot;hello&quot;))
    # we can also use extensions!
    c[:logger].log(&quot;hello world!&quot;)
end</code></pre><hr/><p><strong>field info</strong></p><ul><li>path::String - The path to route to the function, e.g. &quot;/&quot;.</li><li>page::Function - The function to route the path to.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>Route(path::String, f::Function)</li></ul></div></section></article><p>The Route&#39;s constructors are not typically called directly, instead it is probably better to use these methods. Using route! as opposed to route! will modify the routes of a Connection or ToolipsServer</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.route" href="#Toolips.route"><code>Toolips.route</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>route(f::Function, r::String) -&gt; ::Route</strong></p><hr/><p>Creates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection

end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>route(r::String, f::Function) -&gt; ::Route</strong></p><hr/><p>Creates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">function example(c::Connection)
    write!(c, h(&quot;myh&quot;, 1, text = &quot;hello!&quot;))
end
r = route(&quot;/&quot;, example)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.route!" href="#Toolips.route!"><code>Toolips.route!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>route!(c::AbstractConnection, route::Route) -&gt; _</strong></p><hr/><p>Modifies the route on the Connection.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    r = route(&quot;/&quot;) do c::Connection
        write!(c, &quot;hello&quot;)
    end
    route!(c, r)
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>route!(::Function, ::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Routes a given String to the Function.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c
    route!(c, &quot;/&quot;) do c
        println(&quot;tacos&quot;)
    end
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>route!(f::Function, ws::WebServer, r::String) -&gt; _</strong></p><hr/><p>Reroutes a server&#39;s route r to function f.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()
route!(ws, &quot;/&quot;) do c
    c[:Logger].log(&quot;rerouted!&quot;)
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>route!(ws::WebServer, r::String, f::Function) -&gt; _</strong></p><hr/><p>Reroutes a server&#39;s route r to function f.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()

function myf(c::Connection)
    write!(c, &quot;pasta&quot;)
end
route!(ws, &quot;/&quot;, myf)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>route!(ws::WebServer, r::Route) -&gt; _</strong></p><hr/><p>Reroutes a server&#39;s route r.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()
r = route(&quot;/&quot;) do c

end
route!(ws, r)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.unroute!" href="#Toolips.unroute!"><code>Toolips.unroute!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>unroute!(::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Removes the route with the key equivalent to the String.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs"># One request will kill this route:
route(&quot;/&quot;) do c::Connection
    unroute!(c, &quot;/&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes" href="#Toolips.routes"><code>Toolips.routes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(::Route ...) -&gt; ::Vector{Route}</strong></p><hr/><p>Turns routes provided as arguments into a Vector{Route} with indexable routes. This is useful because this is the type that the ServerTemplate constructor likes. This function is also used as a &quot;getter&quot; for WebServers and Connections, see ?(routes(::WebServer)) &amp; ?(routes(::AbstractConnection))</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">r1 = route(&quot;/&quot;) do c::Connection
    write!(c, &quot;pickles&quot;)
end
r2 = route(&quot;/pickles&quot;) do c::Connection
    write!(c, &quot;also pickles&quot;)
end
rts = routes(r1, r2)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>routes(ws::WebServer) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()
routes(ws)
    &quot;/&quot; =&gt; home
    &quot;404&quot; =&gt; fourohfour</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>routes(c::Connection) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    routes(c)
end</code></pre></div></section></article><h2 id="servers"><a class="docs-heading-anchor" href="#servers">servers</a><a id="servers-1"></a><a class="docs-heading-anchor-permalink" href="#servers" title="Permalink"></a></h2><p>ToolipsServers are created by ServerTemplates. Here is a look at how to make a ServerTemplate:</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.ServerTemplate" href="#Toolips.ServerTemplate"><code>Toolips.ServerTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>ServerTemplate</strong></p><ul><li>ip<strong>::String</strong></li><li>port<strong>::Integer</strong></li><li>routes<strong>::Vector{Route}</strong></li><li>extensions<strong>::Dict</strong></li><li>remove<strong>::Function</strong></li><li>add<strong>::Function</strong></li><li>start<strong>::Function</strong> The ServerTemplate is used to configure a server before</li></ul><p>running. These are usually made and started inside of a main server file.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">st = ServerTemplate()

webserver = ServerTemplate.start()</code></pre><hr/><p><strong>field info</strong></p><ul><li>ip<strong>::String</strong> - IP the server should serve to.</li><li>port<strong>::Integer</strong> - Port to listen on.</li><li>routes<strong>::Vector{Route}</strong> - A vector of routes to provide to the server</li><li>extensions<strong>::Vector{ServerExtension}</strong> - A vector of extensions to load into</li></ul><p>the server.</p><ul><li>remove(::Int64)<strong>::Function</strong> - Removes routes by index.</li><li>remove(::String)<strong>::Function</strong> - Removes routes by name.</li><li>remove(::Symbol)<strong>::Function</strong> - Removes extension by Symbol representing</li></ul><p>type, e.g. :Logger</p><ul><li>add(::Route ...)<strong>::Function</strong> - Adds the routes to the server.</li><li>add(::ServerExtension ...)<strong>::Function</strong> - Adds the extensions to the server.</li><li>start()<strong>::Function</strong> - Starts the server.</li></ul><hr/><p><strong>constructors</strong></p><ul><li>ServerTemplate(ip::String = &quot;127.0.0.1&quot;, port::Int64 = 8001,           routes::Vector{Route} = Vector{Route}());           extensions::Vector{ServerExtension} = [Logger()]           connection::Type)</li></ul></div></section></article><p>The ServerTemplate.start() function returns a sub-type of ToolipsServer.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.ToolipsServer" href="#Toolips.ToolipsServer"><code>Toolips.ToolipsServer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type ToolipsServer</strong></p><p>ToolipsServers are returned whenever the ServerTemplate.start() field is called. If you are running your server as a module, it should be noted that commonly a global start() method is used and returns this server, and dev is where this module is loaded, served, and revised.</p><p><strong>Consistencies</strong></p><ul><li>routes::Dict - The server&#39;s route =&gt; function dictionary.</li><li>extensions::Dict - The server&#39;s currently loaded extensions.</li><li>server::Any - The server, whatever type it may be...</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.WebServer" href="#Toolips.WebServer"><code>Toolips.WebServer</code></a> — <span class="docstring-category">Type</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{WebServer, Symbol}" href="#Base.getindex-Tuple{WebServer, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(ws::WebServer, s::Symbol) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in ws.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()
ws[:Logger].log(&quot;hi&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes-Tuple{WebServer}" href="#Toolips.routes-Tuple{WebServer}"><code>Toolips.routes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(ws::WebServer) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()
routes(ws)
    &quot;/&quot; =&gt; home
    &quot;404&quot; =&gt; fourohfour</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.extensions-Tuple{WebServer}" href="#Toolips.extensions-Tuple{WebServer}"><code>Toolips.extensions</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>extensions(ws::WebServer) -&gt; ::Dict{Symbol, ServerExtension}</strong></p><hr/><p>Returns the server&#39;s extensions.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">ws = MyProject.start()
extensions(ws)
    :Logger =&gt; Logger(blah blah blah)</code></pre></div></section></article><h2 id="server-extensions"><a class="docs-heading-anchor" href="#server-extensions">server extensions</a><a id="server-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#server-extensions" title="Permalink"></a></h2><p>Server extensions are provided to the ServerTemplate type. You may read more about them in the developer api. There are also a few default extensions included with toolips. These can be used by passing them in a Symbol-labeled dictionary as the extensions key-word argument on a <strong>ServerTemplate</strong> These are Logger and Files.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.Logger" href="#Toolips.Logger"><code>Toolips.Logger</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Logger &lt;: ServerExtension</strong></p><ul><li>type::Symbol</li><li>out::String</li><li>levels::Dict</li><li>log::Function</li><li>prefix::String</li><li>timeformat::String</li><li>writeat::Int64 A Logger logs information with different levels. Holds the function log(),</li></ul><p>connected to the function _log(). Methods.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">logger = Logger()
st = ServerTemplate(extensions = [Logger()])
r = route(&quot;/&quot;) do c::Connection
    write!(c, &quot;hello world!&quot;)
    c[:Logger].log(&quot;Hello world delivered, mission accomplished.&quot;)
end
st.add(r)
st.start()</code></pre><hr/><p><strong>field info</strong></p><ul><li>type::Symbol - The type of server extension – in this case, Connection.</li><li>out::String - Logfile output directory.</li><li>log(level::Int64, message::String) - Logs the message at the provided level.</li><li>log(message::String) - Logs the message at level 1.</li><li>log(c::Connection, message::String) - Logs to level one and to JavaScript</li></ul><p>console.</p><ul><li>levels::Dict - A {Any, Crayon} dict that contains all of the crayons for the</li></ul><p>logger. Also contains two special crayons under the keys :time<em>crayon and :message</em>crayon</p><ul><li>prefix::String - The prefix to write before the message.</li><li>timeformat::String - A string representing DT format, must be able to be</li></ul><p>passed through the datetime_str macro from Dates.</p><ul><li>writeat::Int64 - The log level to write to out at.</li></ul><hr/><p><strong>constructors</strong></p><p>Logger(levels::Dict{level_count::Int64 =&gt; crayon::Crayons.Crayon};                     out::String = pwd() * &quot;logs/log.txt&quot;) Logger(; out::String = pwd() * &quot;/logs/log.txt&quot;)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.Files" href="#Toolips.Files"><code>Toolips.Files</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Files &lt;: ServerExtension</strong></p><ul><li>type::Symbol</li><li>directory::String</li><li>f::Function Writes all files in directory to their own routes in the server.</li></ul><hr/><p><strong>field info</strong></p><ul><li>type::Symbol - The type of extension. There are three different selections</li></ul><p>you can choose from. <strong>:connection :routing :func</strong>. A :connection extension will be provided in Connection.extensions. A :routing function is passed a Dict of routes as an argument. The last is a function argument, which is just a specific function to run from the top-end to the server.</p><ul><li>directory::String - The directory to route the files from.</li><li>f::Function - The function f() called with a Connection.</li></ul><hr/><p><strong>constructors</strong></p><p>Files(dir::String)</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« servables</a><a class="docs-footer-nextpage" href="../toolips_session/">session extension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 22 June 2022 17:03">Wednesday 22 June 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
