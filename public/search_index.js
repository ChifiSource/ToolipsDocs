var documenterSearchIndex = {"docs":
[{"location":"core/#core","page":"core","title":"core","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Below is a runthrough of all of the documentation pertaining to running a Toolips server.","category":"page"},{"location":"core/#connection","page":"core","title":"connection","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Connection","category":"page"},{"location":"core/#Toolips.Connection","page":"core","title":"Toolips.Connection","text":"Connection <: AbstractConnection\n\nroutes::Dict\nhttp::HTTP.Stream\nextensions::Dict\n\nThe connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.\n\nexample\n\n                  #  v The Connection\nhome = route(\"/\") do c::Connection\n    c[Logger].log(1, \"We can index extensions by type or symbol\")\n    c[:logger].log(1, \"see?\")\n    c.routes[\"/\"] = c::Connection -> write!(c, \"rerouting!\")\n    httpstream = c.http\n    write!(c, \"Hello world!\")\n    myheading::Component = h(\"myheading\", 1, text = \"Whoa!\")\n    write!(c, myheading)\nend\n\n\n\nfield info\n\nroutes::Dict - A dictionary of routes where the keys\n\nare the routed URL and the values are the functions to those keys.\n\nhttp::HTTP.Stream - The stream for this current peer's connection.\nextensions::Dict - A dictionary of extensions to load with the\n\nname to reference as keys and the extension as the pair.\n\nconstructors\n\nConnection(routes::Dict, http::HTTP.Stream, extensions::Dict)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"Connections are served as an argument to incoming routes. Functions are written anticipating a connection return. Here we will write a new route using the route(::Function, ::String) method.","category":"page"},{"location":"core/","page":"core","title":"core","text":"using Toolips\nr = route(\"/\") do c::Connection\n    write!(c, \"Hello!\")\nend","category":"page"},{"location":"core/","page":"core","title":"core","text":"We also use the write!() method on our Connection. We can use this on the types ::Any, ::Vector{Servable}, and ::Servable.","category":"page"},{"location":"core/","page":"core","title":"core","text":"write!","category":"page"},{"location":"core/#Toolips.write!","page":"core","title":"Toolips.write!","text":"Interface\n\nwrite!(c::AbstractConnection, s::Servable) -> _\n\n\n\nWrites a Servable's return to a Connection's stream. This is usually used in a routing function or a route where ::Connection is provided as an argument.\n\nexample\n\nserv = p(\"mycomp\", text = \"hello\")\n\nrt = route(\"/\") do c::Connection\n    write!(c, serv)\nend\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::Vector{Servable}) -> _\n\n\n\nWrites all servables in s to c.\n\nexample\n\nc = Component()\nc2 = Component()\ncomps = components(c, c2)\n    Vector{Servable}(Component(), Component())\n\nwrite!(c, comps)\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::Servable ...) -> _\n\n\n\nWrites Servables as Vector{Servable}\n\nexample\n\nwrite!(c, p(\"mycomp\", text = \"hello!\"), p(\"othercomp\", text = \"hi!\"))\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::Vector{Component}) -> _\n\n\n\nA catch-all for when Vectors are accidentally stored as Vector{Any}.\n\nexample\n\nwrite!(c, [\"hello\", p(\"mycomp\", text = \"hello!\")])\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::Vector{Component}) -> _\n\n\n\nA catch-all for when Vectors are accidentally stored as Vector{Component}.\n\nexample\n\nwrite!(c, [p(\"mycomp\", text = \"bye\")])\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::String) -> _\n\n\n\nWrites the String into the Connection as HTML.\n\nexample\n\nwrite!(c, \"hello world!\")\n\n\n\n\n\nInterface\n\nwrite!(::AbstractConnection, ::Any) -> _\n\n\n\nAttempts to write any type to the Connection's stream.\n\nexample\n\nd = 50\nwrite!(c, d)\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"core","title":"core","text":"Or push any data response into a body and startread the body.","category":"page"},{"location":"core/","page":"core","title":"core","text":"push!(::AbstractConnection, ::Any)\nToolips.startread!(::AbstractConnection)\nToolips.extensions(::Connection)\nroutes(::AbstractConnection)\nhas_extension(::AbstractConnection, ::Type)","category":"page"},{"location":"core/#Base.push!-Tuple{AbstractConnection, Any}","page":"core","title":"Base.push!","text":"Interface\n\npush!(c::AbstractConnection, data::Any) -> _\n\n\n\nA \"catch-all\" for pushing data to a stream. Produces a full response with data as the body.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.startread!-Tuple{AbstractConnection}","page":"core","title":"Toolips.startread!","text":"Interface\n\nstartread!(::AbstractConnection) -> _\n\n\n\nResets the seek on the Connection. This function is only meant to be used on post bodies.\n\nexample\n\npost = getpost(c)\n    \"hello\"\npost = getpost(c)\n    \"\"\nstartread!(c)\npost = getpost(c)\n    \"hello\"\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.extensions-Tuple{Connection}","page":"core","title":"Toolips.extensions","text":"Interface\n\nextensions(c::Connection) -> ::Dict{Symbol, ServerExtension}\n\n\n\nReturns the server's extensions.\n\nexample\n\nroute(\"/\") do c::Connection\n    extensions(c)\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.routes-Tuple{AbstractConnection}","page":"core","title":"Toolips.routes","text":"Interface\n\nroutes(c::Connection) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nroute(\"/\") do c::Connection\n    routes(c)\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.has_extension-Tuple{AbstractConnection, Type}","page":"core","title":"Toolips.has_extension","text":"Interface\n\nhas_extension(c::AbstractConnection, t::Type) -> ::Bool\n\n\n\nChecks if c.extensions has an extension of type t.\n\nexample\n\nif has_extension(c, Logger)\n    c[:Logger].log(\"it has a logger, I think.\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"The connection type can be indexed with Symbols, Strings, and Types. Symbols and Types will index the extensions. Strings will index the routes. The same goes for setting the indexes.","category":"page"},{"location":"core/","page":"core","title":"core","text":"setindex!(::AbstractConnection, ::Function, ::String)\ngetindex(::AbstractConnection, ::Symbol)\ngetindex(::AbstractConnection, ::Type)\ngetindex(::AbstractConnection, ::String)","category":"page"},{"location":"core/#Base.setindex!-Tuple{AbstractConnection, Function, String}","page":"core","title":"Base.setindex!","text":"Interface\n\nsetindex!(c::AbstractConnection, f::Function, s::String) -> _\n\n\n\nSets the route path s to serve at the function f.\n\nexample\n\nc[\"/\"] = c -> write!(c, \"hello\")\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{AbstractConnection, Symbol}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(c::AbstractConnection, s::Symbol) -> ::ServerExtension\n\n\n\nIndexes the extensions in c.\n\nexample\n\nroute(\"/\") do c::Connection\n    c[:Logger].log(\"hi\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{AbstractConnection, Type}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(c::AbstractConnection, t::Type) -> ::ServerExtension\n\n\n\nIndexes the extensions in c by type.\n\nexample\n\nroute(\"/\") do c::Connection\n    c[Logger].log(\"hi\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{AbstractConnection, String}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(c::AbstractConnection, s::String) -> ::Function\n\n\n\nReturns the function that corresponds to the route dir s.\n\nexample\n\nc[\"/\"]\n\n    home\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"We also use the Connection in order to get arguments, download files, and pretty much anything else pertaining to a person's connection.","category":"page"},{"location":"core/","page":"core","title":"core","text":"getarg\ngetargs\ngetip\ngetpost\nToolips.download!\nnavigate!","category":"page"},{"location":"core/#Toolips.getarg","page":"core","title":"Toolips.getarg","text":"Interface\n\ngetarg(c::AbstractConnection, s::Symbol) -> ::Any\n\n\n\nReturns the requested argument from the target.\n\nexample\n\ngetarg(c, :x)\n    50\n\n\n\n\n\nInterface\n\ngetarg(c::AbstractConnection, s::Symbol, t::Type) -> ::Vector\n\n\n\nThis method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that \"Cannot convert...\" errors are possible with this method.\n\nexample\n\ngetarg(c, :x, Int64)\n    50\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getargs","page":"core","title":"Toolips.getargs","text":"Interface\n\ngetargs(c::AbstractConnection) -> ::Dict{Symbol, Any}\n\n\n\nThe getargs method returns arguments from the HTTP target (GET requests.) Returns a Dict with the argument keys as Symbols.\n\nexample\n\nroute(\"/\") do c\n    args = getargs(c)\n    args[:message]\n        \"welcome to toolips ! :)\"\nend\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getip","page":"core","title":"Toolips.getip","text":"Interface\n\ngetip(c::AbstractConnection) -> ::String\n\n\n\nReturns the IP that is connected via the connection c.\n\nexample\n\ngetip(c)\n\"127.0.0.2\"\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getpost","page":"core","title":"Toolips.getpost","text":"Interface\n\ngetpost(c::AbstractConnection) -> ::String\n\n\n\nReturns the POST body of c.\n\nexample\n\ngetpost(c)\n\"hello, this is a post request\"\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.download!","page":"core","title":"Toolips.download!","text":"Interface\n\ndownload!(c::AbstractConnection, uri::String) -> _\n\n\n\nDownloads a file to a given Connection's computer.\n\nexample\n\ndownload!(c, \"files/mytext.txt\")\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.navigate!","page":"core","title":"Toolips.navigate!","text":"Interface\n\nnavigate!(::AbstractConnection, ::String) -> _\n\n\n\nRoutes a connected stream to a given URL.\n\nexample\n\nnavigate!(c, \"https://github.com/ChifiSource/Toolips.jl\")\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"core","title":"core","text":"We can also check if an extension is present by type.","category":"page"},{"location":"core/","page":"core","title":"core","text":"has_extension(::Connection, ::Type)","category":"page"},{"location":"core/#Toolips.has_extension-Tuple{Connection, Type}","page":"core","title":"Toolips.has_extension","text":"Interface\n\nhas_extension(c::AbstractConnection, t::Type) -> ::Bool\n\n\n\nChecks if c.extensions has an extension of type t.\n\nexample\n\nif has_extension(c, Logger)\n    c[:Logger].log(\"it has a logger, I think.\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#routing","page":"core","title":"routing","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"When routing, many methods involve the Connection type we just spoke of. In toolips, routes are handled by the Route type.","category":"page"},{"location":"core/","page":"core","title":"core","text":"Route","category":"page"},{"location":"core/#Toolips.Route","page":"core","title":"Toolips.Route","text":"Route\n\npath::String\npage::Function -\n\nA route is added to a ServerTemplate using either its constructor, or the ServerTemplate.add(::Route) method. Each route calls a function. The Route type is commonly constructed using the do syntax with the route(::Function, ::String) method.\n\nexample\n\n# Constructors\nroute = Route(\"/\", p(text = \"hello\"))\n\nfunction example(c::Connection)\n    write!(c, \"hello\")\nend\n\nroute = Route(\"/\", example)\n\n# method\nroute = route(\"/\") do c\n    write!(c, \"Hello world!\")\n    write!(c, p(text = \"hello\"))\n    # we can also use extensions!\n    c[:logger].log(\"hello world!\")\nend\n\n\n\nfield info\n\npath::String - The path to route to the function, e.g. \"/\".\npage::Function - The function to route the path to.\n\n\n\nconstructors\n\nRoute(path::String, f::Function)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"The Route's constructors are not typically called directly, instead it is probably better to use these methods. Using route! as opposed to route! will modify the routes of a Connection or ToolipsServer","category":"page"},{"location":"core/","page":"core","title":"core","text":"route\nroute!\nunroute!\nroutes","category":"page"},{"location":"core/#Toolips.route","page":"core","title":"Toolips.route","text":"Interface\n\nroute(f::Function, r::String) -> ::Route\n\n\n\nCreates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.\n\nexample\n\nroute(\"/\") do c::Connection\n\nend\n\n\n\n\n\nInterface\n\nroute(r::String, f::Function) -> ::Route\n\n\n\nCreates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.\n\nexample\n\nfunction example(c::Connection)\n    write!(c, h(\"myh\", 1, text = \"hello!\"))\nend\nr = route(\"/\", example)\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.route!","page":"core","title":"Toolips.route!","text":"Interface\n\nroute!(c::AbstractConnection, route::Route) -> _\n\n\n\nModifies the route on the Connection.\n\nexample\n\nroute(\"/\") do c::Connection\n    r = route(\"/\") do c::Connection\n        write!(c, \"hello\")\n    end\n    route!(c, r)\nend\n\n\n\n\n\nInterface\n\nroute!(::Function, ::AbstractConnection, ::String) -> _\n\n\n\nRoutes a given String to the Function.\n\nexample\n\nroute(\"/\") do c\n    route!(c, \"/\") do c\n        println(\"tacos\")\n    end\nend\n\n\n\n\n\nInterface\n\nroute!(f::Function, ws::WebServer, r::String) -> _\n\n\n\nReroutes a server's route r to function f.\n\nexample\n\nws = MyProject.start()\nroute!(ws, \"/\") do c\n    c[:Logger].log(\"rerouted!\")\nend\n\n\n\n\n\nInterface\n\nroute!(ws::WebServer, r::String, f::Function) -> _\n\n\n\nReroutes a server's route r to function f.\n\nexample\n\nws = MyProject.start()\n\nfunction myf(c::Connection)\n    write!(c, \"pasta\")\nend\nroute!(ws, \"/\", myf)\n\n\n\n\n\nInterface\n\nroute!(ws::WebServer, r::Route) -> _\n\n\n\nReroutes a server's route r.\n\nexample\n\nws = MyProject.start()\nr = route(\"/\") do c\n\nend\nroute!(ws, r)\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.unroute!","page":"core","title":"Toolips.unroute!","text":"Interface\n\nunroute!(::AbstractConnection, ::String) -> _\n\n\n\nRemoves the route with the key equivalent to the String.\n\nexample\n\n# One request will kill this route:\nroute(\"/\") do c::Connection\n    unroute!(c, \"/\")\nend\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.routes","page":"core","title":"Toolips.routes","text":"Interface\n\nroutes(::Route ...) -> ::Vector{Route}\n\n\n\nTurns routes provided as arguments into a Vector{Route} with indexable routes. This is useful because this is the type that the ServerTemplate constructor likes. This function is also used as a \"getter\" for WebServers and Connections, see ?(routes(::WebServer)) & ?(routes(::AbstractConnection))\n\nexample\n\nr1 = route(\"/\") do c::Connection\n    write!(c, \"pickles\")\nend\nr2 = route(\"/pickles\") do c::Connection\n    write!(c, \"also pickles\")\nend\nrts = routes(r1, r2)\n\n\n\n\n\nInterface\n\nroutes(ws::WebServer) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nws = MyProject.start()\nroutes(ws)\n    \"/\" => home\n    \"404\" => fourohfour\n\n\n\n\n\nInterface\n\nroutes(c::Connection) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nroute(\"/\") do c::Connection\n    routes(c)\nend\n\n\n\n\n\n","category":"function"},{"location":"core/#servers","page":"core","title":"servers","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"ToolipsServers are created by ServerTemplates. Here is a look at how to make a ServerTemplate:","category":"page"},{"location":"core/","page":"core","title":"core","text":"ServerTemplate","category":"page"},{"location":"core/#Toolips.ServerTemplate","page":"core","title":"Toolips.ServerTemplate","text":"ServerTemplate\n\nip::String\nport::Integer\nroutes::Vector{Route}\nextensions::Dict\nremove::Function\nadd::Function\nstart::Function -\n\nThe ServerTemplate is used to configure a server before running. These are usually made and started inside of a main server file.\n\nexample\n\nst = ServerTemplate()\n\nwebserver = ServerTemplate.start()\n\n\n\nfield info\n\nip::String - IP the server should serve to.\nport::Integer - Port to listen on.\nroutes::Vector{Route} - A vector of routes to provide to the server\nextensions::Vector{ServerExtension} - A vector of extensions to load into\n\nthe server.\n\nremove(::Int64)::Function - Removes routes by index.\nremove(::String)::Function - Removes routes by name.\nremove(::Symbol)::Function - Removes extension by Symbol representing\n\ntype, e.g. :Logger\n\nadd(::Route ...)::Function - Adds the routes to the server.\nadd(::ServerExtension ...)::Function - Adds the extensions to the server.\nstart()::Function - Starts the server.\n\n\n\nconstructors\n\nServerTemplate(ip::String = \"127.0.0.1\", port::Int64 = 8001,           routes::Vector{Route} = Vector{Route}());           extensions::Vector{ServerExtension} = [Logger()]           connection::Type)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"The ServerTemplate.start() function returns a sub-type of ToolipsServer.","category":"page"},{"location":"core/","page":"core","title":"core","text":"ToolipsServer\nWebServer\ngetindex(::WebServer, ::Symbol)\nToolips.routes(::WebServer)\nToolips.extensions(::WebServer)","category":"page"},{"location":"core/#Toolips.ToolipsServer","page":"core","title":"Toolips.ToolipsServer","text":"abstract type ToolipsServer\n\nToolipsServers are returned whenever the ServerTemplate.start() field is called. If you are running your server as a module, it should be noted that commonly a global start() method is used and returns this server, and dev is where this module is loaded, served, and revised.\n\nConsistencies\n\nroutes::Dict - The server's route => function dictionary.\nextensions::Dict - The server's currently loaded extensions.\nserver::Any - The server, whatever type it may be...\n\n\n\n\n\n","category":"type"},{"location":"core/#Toolips.WebServer","page":"core","title":"Toolips.WebServer","text":"WebServer <: ToolipsServer\n\nhost::String\nroutes::Dict\nextensions::Dict\nserver::Any - \n\nA web-server is given as a return from a ServerTemplate whenever ServerTemplate.start() is ran. It can be rerouted with route! and indexed similarly to the Connection, with Symbols representing extensions and Strings representing routes.\n\nexample\n\nst = ServerTemplate()\nws = st.start()\nroutes(ws)\n...\nextensions(ws)\n...\nroute!(ws, \"/\") do c::Connection\n    write!(c, \"hello\")\nend\n\n\n\n\n\n","category":"type"},{"location":"core/#Base.getindex-Tuple{WebServer, Symbol}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(ws::WebServer, s::Symbol) -> ::ServerExtension\n\n\n\nIndexes the extensions in ws.\n\nexample\n\nws = MyProject.start()\nws[:Logger].log(\"hi\")\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.routes-Tuple{WebServer}","page":"core","title":"Toolips.routes","text":"Interface\n\nroutes(ws::WebServer) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nws = MyProject.start()\nroutes(ws)\n    \"/\" => home\n    \"404\" => fourohfour\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.extensions-Tuple{WebServer}","page":"core","title":"Toolips.extensions","text":"Interface\n\nextensions(ws::WebServer) -> ::Dict{Symbol, ServerExtension}\n\n\n\nReturns the server's extensions.\n\nexample\n\nws = MyProject.start()\nextensions(ws)\n    :Logger => Logger(blah blah blah)\n\n\n\n\n\n","category":"method"},{"location":"core/#server-extensions","page":"core","title":"server extensions","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Server extensions are provided to the ServerTemplate type. You may read more about them in the developer api. There are also a few default extensions included with toolips. These can be used by passing them in a Symbol-labeled dictionary as the extensions key-word argument on a ServerTemplate These are Logger and Files.","category":"page"},{"location":"core/","page":"core","title":"core","text":"Logger\nFiles","category":"page"},{"location":"core/#Toolips.Logger","page":"core","title":"Toolips.Logger","text":"Logger <: ServerExtension\n\ntype::Symbol\nout::String\nlevels::Dict\nlog::Function\nprefix::String\ntimeformat::String\nwriteat::Int64 -\n\nA Logger logs information with different levels. Holds the function log(), connected to the function _log(). Methods.\n\nexample\n\nlogger = Logger()\nst = ServerTemplate(extensions = [Logger()])\nr = route(\"/\") do c::Connection\n    write!(c, \"hello world!\")\n    c[:Logger].log(\"Hello world delivered, mission accomplished.\")\nend\nst.add(r)\nst.start()\n\n\n\nfield info\n\ntype::Symbol - The type of server extension – in this case, Connection.\nout::String - Logfile output directory.\nlog(level::Int64, message::String) - Logs the message at the provided level.\nlog(message::String) - Logs the message at level 1.\nlog(c::Connection, message::String) - Logs to level one and to JavaScript\n\nconsole.\n\nlevels::Dict - A {Any, Crayon} dict that contains all of the crayons for the\n\nlogger. Also contains two special crayons under the keys :timecrayon and :messagecrayon\n\nprefix::String - The prefix to write before the message.\ntimeformat::String - A string representing DT format, must be able to be\n\npassed through the datetime_str macro from Dates.\n\nwriteat::Int64 - The log level to write to out at.\n\n\n\nconstructors\n\nLogger(levels::Dict{level_count::Int64 => crayon::Crayons.Crayon};                     out::String = pwd() * \"logs/log.txt\") Logger(; out::String = pwd() * \"/logs/log.txt\")\n\n\n\n\n\n","category":"type"},{"location":"core/#Toolips.Files","page":"core","title":"Toolips.Files","text":"Files <: ServerExtension\n\ntype::Symbol\ndirectory::String\nf::Function - \n\nWrites all files in directory to their own routes in the server.\n\nfield info\n\ntype::Symbol - The type of extension. There are three different selections\n\nyou can choose from. :connection :routing :func. A :connection extension will be provided in Connection.extensions. A :routing function is passed a Dict of routes as an argument. The last is a function argument, which is just a specific function to run from the top-end to the server.\n\ndirectory::String - The directory to route the files from.\nf::Function - The function f() called with a Connection.\n\n\n\nconstructors\n\nFiles(dir::String)\n\n\n\n\n\n","category":"type"},{"location":"interface/#servables","page":"servables","title":"servables","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"Servables are any non-core data-structure that is built with the objective of being written to a stream.","category":"page"},{"location":"interface/#requests","page":"servables","title":"requests","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"Toolips has some bindings that pre-parse responses fro you, these are both post and get requests.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"get\npost","category":"page"},{"location":"interface/#Base.get","page":"servables","title":"Base.get","text":"Interface\n\nget(url::String) -> ::String\n\n\n\nQuick binding for an HTTP GET request.\n\nexample\n\nbody = get(\"/\")\n    \"hi\"\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.post","page":"servables","title":"Toolips.post","text":"Interface\n\npost(url::String, body::String) -> ::String\n\n\n\nQuick binding for an HTTP POST request.\n\nexample\n\nresponse = post(\"/\")\n    \"my response\"\n\n\n\n\n\n","category":"function"},{"location":"interface/#components","page":"servables","title":"components","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"A component is a Servable which contains markup information and can easily be translated into elements with properties..","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"Component","category":"page"},{"location":"interface/#Toolips.Component","page":"servables","title":"Toolips.Component","text":"Component <: Servable\n\nname::String\nf::Function\ntag::String\nproperties::Dict\n\nA component is a standard servable which is used to represent HTML tag structures. Indexing a Component with a Symbol or a String will return or set a Component's property to that index. The two special indexes are :children and :text. :text will change the inner content of the Component and :children is where components that will be written inside the Component go. You can add to these with push!(c::Servable, c2::Servable)\n\nexample\n\nusing Toolips\n\nimage_style = Style(\"example\")\nimage_anim = Animation(\"img_anim\")\nimage_anim[:from] = \"opacity\" => \"0%\"\nimage_anim[:to] = \"opacity\" => \"100%\"\nanimate!(image_style)\n\nr = route(\"/\") do c::AbstractConnection\n    newimage = img(\"newimage\", src = \"/logo.png\")\n    style!(newimage, image_style)\n    write!(c, newimage)\nend\n\n\n\nfield info\n\nname::String - The name field is the way that a component is denoted in code.\nf::Function - The function that gets called with the Connection as an\n\nargument.\n\nproperties::Dict - A dictionary of symbols and values.\n\n\n\nconstructors\n\nComponent(name::String = \"\", tag::String = \"\", properties::Dict = Dict())\nComponent(name::String, tag::String, props::Base.Pairs)\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"Indexing a component will yield its .properties:","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"getindex(::Component, ::Symbol)\ngetindex(::Component, ::String)\nsetindex!(::Servable, ::Any, ::Symbol)\ngetindex(::Vector{Servable}, ::String)\nsetindex!(::Servable, ::Any, ::String)\ngetindex(::Servable, ::String)","category":"page"},{"location":"interface/#Base.getindex-Tuple{Component, Symbol}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(s::Component, symb::Symbol) -> ::Any\n\n\n\nReturns a property value by symbol or name.\n\nexample\n\nc = p(\"hello\", text = \"Hello world\")\nc[:text]\n    \"Hello world!\"\n\nc[\"opacity\"] = \"50%\"\nc[\"opacity\"]\n    \"50%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.getindex-Tuple{Component, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(::Servable, ::String) -> ::Any\n\n\n\nReturns a property value by string or name.\n\nexample\n\nc = p(\"hello\", text = \"Hello world\")\nc[:text]\n    \"Hello world!\"\n\nc[\"opacity\"] = \"50%\"\nc[\"opacity\"]\n    \"50%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.setindex!-Tuple{Servable, Any, Symbol}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(s::Servable, a::Any, symb::Symbol) -> _\n\n\n\nSets the property represented by the symbol to the provided value.\n\nexample\n\nc = p(\"world\")\nc[:text] = \"hello world!\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.getindex-Tuple{Vector{Servable}, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(c::VectorServable, str::String) -> ::Servable\n\n\n\nReturns the Servable (likely a Component) with the name str\n\nexample\n\ncomp1 = p(\"hello\")\ncomp2 = p(\"anotherp\")\ncs = components(comp1, comp2)\ncs[\"hello\"]\n    Component(\"hello\" ...)\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.setindex!-Tuple{Servable, Any, String}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(s::Servable, a::Any, symb::String) -> _\n\n\n\nSets the property represented by the string to the provided value. Use the appropriate web-format, such as \"50%\" or \"50px\".\n\nexample\n\nc = p(\"world\")\nc[\"align\"] = \"center\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.getindex-Tuple{Servable, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(::Servable, ::String) -> ::Any\n\n\n\nReturns a property value by string or name.\n\nexample\n\nc = p(\"hello\", text = \"Hello world\")\nc[:text]\n    \"Hello world!\"\n\nc[\"opacity\"] = \"50%\"\nc[\"opacity\"]\n    \"50%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"servables","title":"servables","text":"There is a library of default components that comes with toolips. Generally, their name coincides with a docstring. All of these take an infinite number of key-word arguments. These arguments become the properties of a Servable.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"img\nlink\nmeta\ninput\na\np\nh\nul\nli\ndivider\nbr\ni\ntitle\nspan\niframe\nsvg\nelement\nlabel\nscript\nnav\nbutton\nform\nToolips.footer\nbody\nheader\nsection","category":"page"},{"location":"interface/#Toolips.img","page":"servables","title":"Toolips.img","text":"img(name::String; args ...) -> ::Component\n\n\n\nReturns the img Component with the key-word arguments provided in args as properties.\n\nexample\n\nimage = img(\"mylogo\", src = \"assets/logo.png\")\nwrite!(c, image)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.link","page":"servables","title":"Toolips.link","text":"link(name::String; args ...) -> ::Component\n\n\n\nReturns the link Component with the key-word arguments provided in args as properties.\n\nexample\n\nmylink = link(\"mylink\", href = \"http://toolips.app\")\nwrite!(c, mylink)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.meta","page":"servables","title":"Toolips.meta","text":"meta(name::String; args ...) -> ::Component\n\n\n\nReturns the meta Component with the key-word arguments provided in args as properties.\n\nexample\n\nmetainfo = meta(\"metainfo\", rel = \"meta-description\", text = \"hello\")\nwrite!(c, metainfo)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.input","page":"servables","title":"Toolips.input","text":"input(name::String; args ...) -> ::Component\n\n\n\nReturns the input Component with the key-word arguments provided in args as properties.\n\nexample\n\nelement = input(\"mylogo\")\nwrite!(c, element)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.a","page":"servables","title":"Toolips.a","text":"a(name::String; args ...) -> ::Component\n\n\n\nReturns the a Component with the key-word arguments provided in args as properties.\n\nexample\n\nelement = a(\"mylogo\")\nwrite!(c, element)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.p","page":"servables","title":"Toolips.p","text":"p(name::String; args ...) -> ::Component\n\n\n\nReturns the p Component with the key-word arguments provided in args as properties.\n\nexample\n\np1 = input(\"mylogo\")\nwrite!(c, p)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.h","page":"servables","title":"Toolips.h","text":"h(name::String; args ...) -> ::Component\n\n\n\nReturns the h Component with the key-word arguments provided in args as properties.\n\nexample\n\nh1 = h(\"heading1\", 1)\nwrite!(c, h1)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.ul","page":"servables","title":"Toolips.ul","text":"ul(name::String; args ...) -> ::Component\n\n\n\nReturns the ul Component with the key-word arguments provided in args as properties.\n\nexample\n\nul1 = ul(\"mylogo\")\nwrite!(c, ul)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.li","page":"servables","title":"Toolips.li","text":"li(name::String; args ...) -> ::Component\n\n\n\nReturns the li Component with the key-word arguments provided in args as properties.\n\nexample\n\nli1 = li(\"mylogo\")\nwrite!(c, li)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.divider","page":"servables","title":"Toolips.divider","text":"divider(name::String; args ...) -> ::Component\n\n\n\nReturns the div Component with the key-word arguments provided in args as properties.\n\nexample\n\ndivider1 = divider(\"mylogo\")\nwrite!(c, divider)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.br","page":"servables","title":"Toolips.br","text":"br(name::String; args ...) -> ::Component\n\n\n\nReturns the br Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = br(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.i","page":"servables","title":"Toolips.i","text":"i(name::String; args ...) -> ::Component\n\n\n\nReturns the i Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = i(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.title","page":"servables","title":"Toolips.title","text":"title(name::String; args ...) -> ::Component\n\n\n\nReturns the title Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = title(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.span","page":"servables","title":"Toolips.span","text":"span(name::String; args ...) -> ::Component\n\n\n\nReturns the span Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = span(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.iframe","page":"servables","title":"Toolips.iframe","text":"iframe(name::String; args ...) -> ::Component\n\n\n\nReturns the iframe Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = iframe(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.svg","page":"servables","title":"Toolips.svg","text":"svg(name::String; args ...) -> ::Component\n\n\n\nReturns the svg Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = svg(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.element","page":"servables","title":"Toolips.element","text":"element(name::String; args ...) -> ::Component\n\n\n\nReturns the element Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = element(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.label","page":"servables","title":"Toolips.label","text":"label(name::String; args ...) -> ::Component\n\n\n\nReturns the label Component with the key-word arguments provided in args as properties.\n\nexample\n\nlbl = label(\"mylogo\", src = \"assets/logo.png\")\nwrite!(c, lbl)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.script","page":"servables","title":"Toolips.script","text":"script(name::String; args ...) -> ::Component\n\n\n\nReturns the script Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = script(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.nav","page":"servables","title":"Toolips.nav","text":"nav(name::String; args ...) -> ::Component\n\n\n\nReturns the nav Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = nav(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.button","page":"servables","title":"Toolips.button","text":"button(name::String; args ...) -> ::Component\n\n\n\nReturns the button Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = button(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.form","page":"servables","title":"Toolips.form","text":"form(name::String; args ...) -> ::Component\n\n\n\nReturns the form Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = form(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.footer","page":"servables","title":"Toolips.footer","text":"footer(name::String; args ...) -> ::Component\n\n\n\nReturns the form Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = footer(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.body","page":"servables","title":"Toolips.body","text":"body(name::String; args ...) -> ::Component\n\n\n\nReturns the form Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = body(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.header","page":"servables","title":"Toolips.header","text":"header(name::String; args ...) -> ::Component\n\n\n\nReturns the form Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = header(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.section","page":"servables","title":"Toolips.section","text":"section(name::String; args ...) -> ::Component\n\n\n\nReturns the form Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = section(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"servables","title":"servables","text":"We can also compose components together using push!, and work with them using the following methods:","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"push!(::Component, ::Component ...)\nstyle!\ncomponents\nToolips.copy(::Component)\nToolips.has_children\nToolips.children\nToolips.getproperties\nToolips.properties!\ngetindex(::)","category":"page"},{"location":"interface/#Base.push!-Tuple{Component, Vararg{Component}}","page":"servables","title":"Base.push!","text":"Interface\n\npush!(s::Component, d::Component ...) -> ::Component\n\n\n\nAdds the child or children d to s.properties[:children]\n\nexample\n\nc = Component()\notherc = Component()\npush!(c, otherc)\n\n\n\n\n\n","category":"method"},{"location":"interface/#Toolips.style!","page":"servables","title":"Toolips.style!","text":"Interface\n\nstyle!(c::Servable, s::Style) -> _\n\n\n\nApplies the style to a servable.\n\nexample\n\nserv = p(\"wow\")\nmystyle = Style(\"mystyle\", color = \"lightblue\")\nstyle!(serv, mystyle)\n\n\n\n\n\nInterface\n\nstyle!(c::Servable, s::Pair ...) -> _\n\n\n\nApplies the style pairs to the servable's \"style\" property.\n\nexample\n\nmycomp = p(\"mycomp\")\nstyle!(mycomp, \"background-color\" => \"lightblue\", \"color\" => \"white\")\n\n\n\n\n\nInterface\n\nstyle!(c::Servable, s::Vector{Pair}) -> _\n\n\n\nApplies the style pairs to the servable's \"style\" property.\n\nexample\n\nmycomp = p(\"mycomp\")\nstyle!(mycomp, [\"background-color\" => \"lightblue\", \"color\" => \"white\"])\n\n\n\n\n\nInterface\n\nstyle!(::Style, ::Style) -> _\n\n\n\nCopies the properties from the second style into the first style.\n\nexample\n\nstyle1 = Style(\"firsts\")\nstyle2 = Style(\"seconds\")\nstyle1[\"color\"] = \"orange\"\nstyle!(style2, style1)\n\nstyle2[\"color\"]\n    \"orange\"\n\n\n\n\n\nSession Interface\n\nstyle!(cm::ComponentModifier, s::Servable, style::Style) -> _\n\n\n\nChanges the style class of s to the style p. Note – styles must be already written to the Connection prior.\n\nexample\n\n\n\n\n\n\n\nSession Interface\n\nstyle!(cm::ComponentModifier, name::String, sname::String) -> _\n\n\n\nChanges the style class of a Servable by name to the style p by name. Note – styles must be already written to the Connection prior.\n\nexample\n\n\n\n\n\n\n\nSession Interface\n\nstyle!(cm::ComponentModifier, s::Servable, p::Pair{String, String}) -> _\n\n\n\nStyles the Servable s with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\nSession Interface\n\nstyle!(cm::ComponentModifier, s::Servable, p::Pair) -> _\n\n\n\nStyles the Servable s with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\nSession Interface\n\nstyle!(cm::ComponentModifier, name::String, p::Pair) -> _\n\n\n\nStyles a Servable by name with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\nSession Interface\n\nstyle!(cm::ComponentModifier, name::String, p::Vector{Pair{String, String}}) -> _\n\n\n\nStyles a Servable by name with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.components","page":"servables","title":"Toolips.components","text":"Interface\n\ncomponents(cs::Servable ...) -> ::Vector{Servable}\n\n\n\nCreates a Vector{Servable} from multiple servables. This is useful because a vector of components could potentially become a Vector{Component}, for example and this is not the dispatch that is used universally across the package.\n\nexample\n\nc = Component()\nc2 = Component()\ncomponents(c, c2)\n    Vector{Servable}(Component(), Component())\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.copy-Tuple{Component}","page":"servables","title":"Toolips.copy","text":"Interface\n\ncopy(c::Component) -> ::Component\n\n\n\ncopies c.\n\nexample\n\nc = p(\"myp\")\nt = copy!(c)\n\n\n\n\n\n","category":"method"},{"location":"interface/#Toolips.has_children","page":"servables","title":"Toolips.has_children","text":"Interface\n\nhas_children(c::Component) -> ::Bool\n\n\n\nReturns true if the given component has children.\n\nexample\n\nc = Component()\notherc = Component()\npush!(c, otherc)\n\nhas_children(c)\n    true\nhas_children(otherc)\n    false\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.children","page":"servables","title":"Toolips.children","text":"Interface\n\nchildren(c::Component) -> ::Vector{Servable}\n\n\n\nReturns Vector{Servable} of children inside of c.\n\nexample\n\nchildren(c)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.getproperties","page":"servables","title":"Toolips.getproperties","text":"Interface\n\ngetproperties(c::Component) -> ::Dict\n\n\n\nReturns a Dict of properties inside of c.\n\nexample\n\nprops = properties(c)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.properties!","page":"servables","title":"Toolips.properties!","text":"Interface\n\nproperties!(c::Servable, s::Servable) -> _\n\n\n\nCopies properties from s,properties into c.properties.\n\nexample\n\ncomp = Component()\nothercomp = Component()\nothercomp[\"opacity\"] = \"100%\"\nproperties!(comp, othercomp)\n\ncomp[\"opacity\"]\n        100%\n\n\n\n\n\n","category":"function"},{"location":"interface/#style-components","page":"servables","title":"style components","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"Style components change the style of a Component","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"StyleComponent","category":"page"},{"location":"interface/#Toolips.StyleComponent","page":"servables","title":"Toolips.StyleComponent","text":"abstract type StyleComponent <: Servable\n\nNo different from a normal Servable, simply an abstract type step for the interface to separate working with Animations and Styles.\n\nServable Consistencies\n\nServables can be written to a Connection via thier f() function and the\ninterface. They can also be indexed with strings or symbols to change properties\n##### Consistencies\n- f::Function - Function whose output to be written to http. Must take a single\npositonal argument of type ::Connection or ::AbstractConnection\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"The main style components are Animations and Styles.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"Toolips.Style\n(:)(::Style, ::String, ::Pair ...)","category":"page"},{"location":"interface/#Toolips.Style","page":"servables","title":"Toolips.Style","text":"Style\n\nname::String\nf::Function\nproperties::Dict{Any, Any}\nextras::Vector{Servable}\n\nCreates a style from attributes, can style a Component using the style! method. Names should be consistent with CSS names. For example, a default h1 style would be named \"h1\". A heading style for a specific class should be \"h1.myheading\"\n\nexample\n\nstyle = Style(\"p.mystyle\", color = \"blue\")\nstyle[\"opacity\"] = \"50%\"\ncomp = Component()\nstyle!(comp, style)\n\n\n\nfield info\n\nname::String - The name of the style. Should be consistent with CSS naming.\nf::Function - The function f, called by write! when writing to a Connection.\nproperties::Dict{Any, Any} - A dict of style attributes.\nextras::String - Extra components to be written along with the style. Usually\n\nthis is an animation.\n\nconstructors\n\nStyle(name::String; props ...)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Base.::-Tuple{Style, String, Vararg{Pair}}","page":"servables","title":"Base.::","text":"Interface\n\n:(s::Style, name::String, ps::Pair ...)\n\n\n\nCreates a sub-style of a given style with the pairs provided in ps.\n\nexample\n\ns = Style(\"buttonstyle\", color = \"white\")\ns[\"background-color\"] = \"blue\"\ns:\"hover\", \"background-color\" => \"blue\"\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"servables","title":"servables","text":"Animation\nanimate!\ndelete_keyframe!","category":"page"},{"location":"interface/#Toolips.Animation","page":"servables","title":"Toolips.Animation","text":"Animation\n\nname::String\nkeyframes::Dict\nf::Function\ndelay::Float64\nlength::Float64\niterations::Integer\n\nAn animation can be used to animate Styles with the animate! method. Animating is done by indexing by either percentage, or symbols, such as from and to.\n\nexample\n\nanim = Animation(\"myanim\")\nanim[:from] = \"opacity\" => \"0%\"\nanim[:to] = \"opacity\" => \"100%\"\nstyle = Style(\"example\")\nanimate!(style, anim)\n\n\n\nfield info\n\nname::String - The name of the animation.\nkeyframes::Dict - The keyframes that have been pushed so far.\nf::Function - The function called when writing to a Connection.\ndelay::Float64 - The delay before the animation begins.\nlength::Float64 - The amount of time the animation should play.\niterations::Integer - The number of times the animation should repeat. When\n\nset to 0 the animation will loop indefinitely.\n\nconstructors\n\nAnimation(name::String = \"animation\", delay::Float64 = 0.0,         length::Float64 = 5.2, iterations::Integer = 1)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Toolips.animate!","page":"servables","title":"Toolips.animate!","text":"Interface\n\nanimate!(s::Style, a::Animation) -> _\n\n\n\nSets the Animation as a property of the style.\n\nexample\n\nanim = Animation(\"fade_in\")\nanim[:from] = \"opacity\" => \"0%\"\nanim[:to] = \"opacity\" => \"100%\"\n\nanimated_style = Style(\"example\")\nanimate!(animated_style, anim)\n\n\n\n\n\nInterface\n\nanimate!(s::Component, a::Animation) -> _\n\n\n\nSets the animation of a Component directly\n\nexample\n\nanim = Animation(\"fade_in\")\nanim[:from] = \"opacity\" => \"0%\"\nanim[:to] = \"opacity\" => \"100%\"\n\nmyp = p(\"myp\", text = \"I fade in!\")\nanimate!(myp, anim)\n\n\n\n\n\nSession Interface\n\nanimate!(cm::ComponentModifier, s::Servable, a::Animation; play::Bool) -> _\n\n\n\nUpdates the servable s's animation with the animation a.\n\nexample\n\ns = divider(\"mydiv\")\na = Animation(\"fade\")\na[:from] = \"opacity\" => \"0%\"\na[:to] = \"opacity\" => \"100%\"\n# where c is the Connection.\non(c, s, \"click\") do cm::ComponentModifier\n    animate!(cm, s, a)\nend\n\n\n\n\n\nSession Interface\n\nanimate!(cm::ComponentModifier, s::String, a::Animation; play::Bool) -> _\n\n\n\nUpdates the servable with name s's animation with the animation a.\n\nexample\n\n``` s = divider(\"mydiv\") a = Animation(\"fade\") a[:from] = \"opacity\" => \"0%\" a[:to] = \"opacity\" => \"100%\"\n\nwhere c is the Connection.\n\non(c, s, \"click\") do cm::ComponentModifier     animate!(cm, s, a) end      ```\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.delete_keyframe!","page":"servables","title":"Toolips.delete_keyframe!","text":"Interface\n\ndelete_keyframe!(a::Animation, key::Int64) -> _\n\n\n\nDeletes a given keyframe from an animation by keyframe percentage.\n\nexample\n\nanim = Animation(\"\")\nanim[0] = \"opacity\" => \"0%\"\ndelete_keyframe!(anim, 0)\n\n\n\n\n\nInterface\n\ndelete_keyframe!(a::Animation, key::Symbol) -> _\n\n\n\nDeletes a given keyframe from an animation by keyframe name.\n\nexample\n\nanim = Animation(\"\")\nanim[:to] = \"opacity\" => \"0%\"\ndelete_keyframe!(anim, :to)\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"servables","title":"servables","text":"Animating and property adjustment is done with indexing.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"setindex!(::Animation, ::Pair, ::Symbol)\nsetindex!(::Animation, ::Pair, ::Int64)","category":"page"},{"location":"interface/#Base.setindex!-Tuple{Animation, Pair, Symbol}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(anim::Animation, set::Pair, n::Symbol) -> _\n\n\n\nSets the animation at the corresponding key-word's position. Usually these are :to and :from.\n\nexample\n\na = Animation(\"world\")\na[:to] = \"opacity\" => \"0%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.setindex!-Tuple{Animation, Pair, Int64}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(anim::Animation, set::Pair, n::Int64) -> _\n\n\n\nSets the animation at the percentage of the Int64 to modify the properties of pair.\n\nexample\n\na = Animation(\"world\")\na[0] = \"opacity\" => \"0%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#other-servables","page":"servables","title":"other servables","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"The file Servable, as you might expect, serves a file via a directory.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"File","category":"page"},{"location":"interface/#Toolips.File","page":"servables","title":"Toolips.File","text":"File <: Servable\n\ndir::String f::Function Serves a file into a Connection.\n\nexample\n\nf = File(\"hello.txt\")\nr = route(\"/\") do c\n    write!(c, f)\nend\n\n\n\nfield info\n\ndir::String - The directory of a file to serve.\nf::Function - Function whose output to be written to http().\n\n\n\nconstructors\n\nFile(dir::String)\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"Servables are also incredibly easy to write, and part of the beauty of toolips is just how easy it is to create these kinds of extensions in toolips!","category":"page"},{"location":"creating_servables/#creating-servables","page":"creating servables","title":"creating servables","text":"","category":"section"},{"location":"creating_servables/","page":"creating servables","title":"creating servables","text":"Servables are probably the most approachable type to make for your first extension. Servable extensions work by simply making a sub-type of Servable. For example, the Component's source code:","category":"page"},{"location":"creating_servables/","page":"creating servables","title":"creating servables","text":"function Component(name::String = \"\", tag::String = \"\",\n     properties::Dict = Dict{Any, Any}())\n     push!(properties, :children => Vector{Servable}())\n     extras = Vector{Servable}()\n     f(c::AbstractConnection) = begin\n         open_tag::String = \"<$tag id = $name \"\n         text::String = \"\"\n         write!(c, open_tag)\n         for property in keys(properties)\n             special_keys = [:text, :children]\n             if ~(property in special_keys)\n                 prop::String = string(properties[property])\n                 propkey::String = string(property)\n                 write!(c, \" $propkey = $prop \")\n             else\n                 if property == :text\n                     text = properties[property]\n                 end\n             end\n         end\n         write!(c, \">\")\n         if length(properties[:children]) > 0\n             write!(c, properties[:children])\n        end\n        write!(c, \"$text</$tag>\")\n        write!(c, extras)\n     end\n     new(name, f, properties, extras, tag)::Component\nend","category":"page"},{"location":"creating_servables/","page":"creating servables","title":"creating servables","text":"The Interface portion of this module is actually built as a Toolips extension itself. Anyway, as you can see, the function f is provided. This is the one consistent field every servable must have. In that field you are able to write to the document with text how you normally would. That being said, Servable extensions can be used simply to generate one portion of your website while holding some information in a constructor. As soon as it is created, it is immediately dispatched to methods like write!, etc. Here is another, more simple example where we write a header.","category":"page"},{"location":"creating_servables/","page":"creating servables","title":"creating servables","text":"Toolips.Servable","category":"page"},{"location":"creating_servables/#Toolips.Servable","page":"creating servables","title":"Toolips.Servable","text":"abstract type Servable\n\nServables can be written to a Connection via thier f() function and the interface. They can also be indexed with strings or symbols to change properties\n\nConsistencies\n\nf::Function - Function whose output to be written to http. Must take a single\n\npositonal argument of type ::Connection or ::AbstractConnection\n\n\n\n\n\n","category":"type"},{"location":"creating_servables/","page":"creating servables","title":"creating servables","text":"import Toolips: Servable\nmutable struct MyHeader <: Servable\n    f::Function\n    cs::Vector{Servable}\n    function MyHeader(name = \"Hello World\")\n        anim = Animation(\"fade_in\")\n        div_s = Style(\"div.myheaderstyle\", color = \"lightblue\")\n        header_div = divider(\"header_div\", align = \"center\")\n        heading = h(1, \"Hello, welcome!\", align = \"center\")\n        style!(heading, \"color\" => \"white\")\n        push!(header_div, heading)\n        animate!(div_s, anim)\n        cs = components(div_s, header_div)\n        f(c::Connection) = write!(c, cs)\n        new(f, cs)\n    end\nend","category":"page"},{"location":"creating_servables/","page":"creating servables","title":"creating servables","text":"Is this the best way to serve your websites? It could be depending on your application!","category":"page"},{"location":"developer_api/#creating-extensions","page":"extending toolips","title":"creating extensions","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"There are both Connection and Server extensions. Here is how to make them.","category":"page"},{"location":"developer_api/#creating-connection-extensions","page":"extending toolips","title":"creating connection extensions","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.AbstractConnection","category":"page"},{"location":"developer_api/#Toolips.AbstractConnection","page":"extending toolips","title":"Toolips.AbstractConnection","text":"abstract type AbstractConnection\n\nConnections are passed through function routes and can have Servables written     to it.\n\nConsistencies\n\nroutes::Dict - A {String, Function} dictionary that the server references to\n\ndirect incoming connections.\n\nhttp::Any - Usually an HTTP.Stream, however can be anything that is binded to\n\nthe Base.write method.\n\nextensions::Dict - A {Symbol, ServerExtension} dictionary that can be used to\n\naccess ServerExtensions.\n\n\n\n\n\n","category":"type"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Abstract Connections must have the extensions Dict, the routing Dict, and some sort of writable stream called http. This needs to be binded to Base.write. A good example of this is Toolips.SpoofStream and Toolips.SpoofConnection, which can be used to write connection output to a string.","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"mutable struct SpoofStream\n    text::String\n    SpoofStream() = new(\"\")\nend","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"The http value can be anything, so in this case it will be a SpoofStream. The SpoofStream contains only a string, text. This is then binded to the write method:","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"write(s::SpoofStream, e::Any) = s.text = s.text * string(e)\nwrite(c::SpoofStream, s::Servable) = s.f(c)","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Finally, we make our connection, using SpoofStream as HTTP.","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"mutable struct SpoofConnection <: AbstractConnection\n    routes::Dict\n    http::SpoofStream\n    extensions::Dict\n    function SpoofConnection(r::Dict, http::SpoofStream, extensions::Dict)\n        new(r, SpoofStream(), extensions)\n    end\n    SpoofConnection() = new(Dict(), SpoofStream(), Dict())\nend","category":"page"},{"location":"developer_api/#creating-server-extensions","page":"extending toolips","title":"creating server extensions","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.ServerExtension","category":"page"},{"location":"developer_api/#Toolips.ServerExtension","page":"extending toolips","title":"Toolips.ServerExtension","text":"abstract type ServerExtension\n\nServer extensions are loaded into the server on startup, and can have a few different abilities according to their type field's value. This value can be either a Symbol or a Vector of Symbols.\n\nConsistencies\n\ntype::T where T == Vector{Symbol}  || T == Symbol. The type can be :routing,\n\n:func, :connection, or any combination inside of a Vector{Symbol}. :routing ServerExtensions must have an f() function that takes two dictionaries; e.g. f(r::Dict{String, Function}, e::Dict{Symbol, ServerExtension}) The first Dict is the dictionary of routes, the second is the dictionary of server extensions. :func server extensions will be ran everytime the server is routed. They will need to have the same f function, but taking a single argument as a connection.     Lastly, :connection extensions are simply pushed to the connection.\n\n\n\n\n\n","category":"type"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Server extensions are a little bit more intense. There are three types of server extensions, :func, :routing, and :connection. The type field can be either a Vector{Symbol}, or a single symbol – and a combination of each of these can be written. A :func extension is one that holds a function that is ran every time a Connection is routed. A :func extension requires that the function f(::AbstractConnection) or f(::Connection) exists inside of it. Here is an example:","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"import Toolips: ServerExtension\n\nmutable struct MyExtension <: ServerExtension\n    f::Function\n    function MyExtension()\n        f(c::Connection) = begin\n            write!(c, \"Hello!\")\n        end\n    end\nend","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Each time the server is routed, there will now be \"Hello!\" written to the top of the page. A :routing extension is similar, but we will want to have the f function instead take two dictionaries. The dictionaries are specifically of type Dict{String, Function}, and Dict{Symbol, ServerExtension}. A great example of this is the Toolips.Files extension:","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"mutable struct Files <: ServerExtension\n    type::Symbol\n    directory::String\n    f::Function\n    function Files(directory::String = \"public\")\n        f(r::Dict, e::Dict) = begin\n            l = length(directory) + 1\n            for path in route_from_dir(directory)\n                push!(r, path[l:length(path)] => c::Connection -> write!(c, File(path)))\n            end\n        end\n        new(:routing, directory, f)\n    end\nend","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Finally, there is also a :connection extension. These are extensions that are to be pushed into the Connection's extensions field. Nothing extra needs to be done to these types of extensions. A great example of this is the Toolips.Logger:","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"mutable struct Logger <: ServerExtension\n    type::Symbol\n    out::String\n    levels::Dict\n    log::Function\n    prefix::String\n    timeformat::String\n    writeat::Int64\n    function Logger(levels::Dict{Any, Crayon} = Dict(\n    1 => Crayon(foreground = :light_cyan),\n    2 => Crayon(foreground = :light_yellow),\n    3 => Crayon(foreground = :yellow, bold = true),\n    4 => Crayon(foreground = :red, bold = true),\n    :time_crayon => Crayon(foreground = :magenta, bold = true),\n     :message_crayon => Crayon(foreground  = :light_blue, bold = true)\n    );\n    out::String = pwd() * \"/logs/log.txt\", prefix::String = \"🌷 toolips> \",\n                    timeformat::String = \"YYYY:mm:dd:HH:MM\", writeat::Int64 = 2)\n\n        log(level::Int64, message::String) = _log(level, message, levels, out,\n                                                prefix, timeformat, writeat)\n        log(message::String) = _log(1, message, levels, out, prefix, timeformat,\n        writeat)\n        log(c::Connection, message::String) = _log(c, message)\n        # These bindings are left open-ended for extending via\n                                            # import Toolips._log\n        log(level::Int64, message::Any) = _log(level, a, levels, out, prefix,\n                                            timeformat)\n        new(:connection, out::String, levels::Dict, log::Function,\n                    prefix::String, timeformat::String, writeat::Int64)::Logger\n    end\nend","category":"page"},{"location":"developer_api/#toolips-internals","page":"extending toolips","title":"toolips internals","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"If you're looking at the internals, you are probably good enough at reading documentation... Here are the doc-strings, my friend. Thank you for contributing.","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.write(::SpoofStream, ::Any)\nToolips.write(::SpoofStream, ::Servable)\nToolips.create_serverdeps\nToolips.serverfuncdefs\nToolips._start\nToolips.generate_router\nToolips._log\nToolips.string\nToolips.SpoofConnection\nToolips.SpoofStream\nToolips.route_from_dir\nToolips.show(::Base.TTY, ::Component)\nToolips.show(::Component)\nToolips.show_log\nToolips.@L_str\nToolips.has_extension(d::Dict, t::Type)\nToolips.argsplit\nToolips.string(::Vector{UInt8})\nToolips.showchildren","category":"page"},{"location":"developer_api/#Base.write-Tuple{SpoofStream, Any}","page":"extending toolips","title":"Base.write","text":"Internals\n\nwrite(s::SpoofStream, e::Any) -> _\n\n\n\nA binding to Base.write that allows one to write to SpoofStream.text.\n\nexample\n\ns = SpoofStream()\nwrite(s, \"hi\")\nprintln(s.text)\n    hi\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Base.write-Tuple{SpoofStream, Servable}","page":"extending toolips","title":"Base.write","text":"Internals\n\nwrite(s::SpoofStream, e::Servable) -> _\n\n\n\nA binding to Base.write that allows one to write a Servable to SpoofStream.text.\n\nexample\n\ns = SpoofStream()\nwrite(s, p(\"hello\"))\nprintln(s.text)\n    <p id = \"hello\"></p>\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.create_serverdeps","page":"extending toolips","title":"Toolips.create_serverdeps","text":"Internals\n\ncreate_serverdeps(name::String, inc::String) -> _\n\n\n\nCreates the essential portions of the webapp file structure, where name is the project's name and inc is any extensions or strings to incorporate at the top of the file.\n\nexample\n\ncreate_serverdeps(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.serverfuncdefs","page":"extending toolips","title":"Toolips.serverfuncdefs","text":"Core\n\nserverfuncdefs(::AbstractVector, ::String, ::Integer,\n\n::Dict) -> (::Function, ::Function, ::Function)\n\nThis method is used internally by a constructor to generate the functions add, start, and remove for the ServerTemplate.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips._start","page":"extending toolips","title":"Toolips._start","text":"Core - Internals\n\n_start(routes::AbstractVector, ip::String, port::Integer,\n\nextensions::Dict, c::Type) -> ::WebServer\n\nThis is an internal function for the ServerTemplate. This function is binded to     the ServerTemplate.start field.\n\nexample\n\nst = ServerTemplate()\nst.start()\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.generate_router","page":"extending toolips","title":"Toolips.generate_router","text":"Core - Internals\n\ngenerate_router(routes::AbstractVector, server::Any, extensions::Dict,\n\n        conn::Type)\n\n\n\nThis method is used internally by the _start method. It returns a closure function that both routes and calls functions.\n\nexample\n\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, ip), port))\nif has_extension(extensions, Logger)\n    extensions[Logger].log(1,\n     \"Toolips Server starting on port \" * string(port))\nend\nroutefunc, rdct, extensions = generate_router(routes, server, extensions,\n                                                Connection)\n@async HTTP.listen(routefunc, ip, port, server = server)\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips._log","page":"extending toolips","title":"Toolips._log","text":"Extensions\n\n_log(level::Int64, message::String, levels::Dict, out::String) -> _\n\n\n\nBinded call for the field log() inside of Logger(). See ?(Logger) for more     details on the field log. All arguments are fields of that type. Return is a     printout into the REPL as well as an append to the log file, provided by the     out URI. –––––––––\n\nexample (Closure from Logger)\n\nlog(level::Int64, message::String) = _log(level, message, levels, out)\nlog(message::String) = _log(1, message, levels, out)\n\n\n\n\n\nExtensions\n\n_log(http::HTTP.Stream, message::String) -> _\n\n\n\nBinded call for the field log() inside of Logger(). This will log both to the     JavaScript/HTML console. –––––––––\n\nexample (Closure from Logger)\n\nlog(http::HTTP.Stream, message::String) = _log(http, message)\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Base.string","page":"extending toolips","title":"Base.string","text":"Internals\n\nstring(r::Vector{UInt8}) -> ::String\n\n\n\nTurns a vector of UInt8s into a string.\n\n\n\n\n\nInterface\n\nstring(c::Component) -> ::String\n\n\n\nShows c as a string representation of itself.\n\nexample\n\nc = divider(\"example\", align = \"center\")\nstring(c)\n    \"divider: align = center\"\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.SpoofConnection","page":"extending toolips","title":"Toolips.SpoofConnection","text":"SpoofConnection <: AbstractConnection\n\nroutes::Dict\nhttp::SpoofStream\nextensions::Dict -\n\nBuilds a fake connection with a SpoofStream. Useful if you want to write a Servable without a server.\n\nexample\n\nfakec = SpoofConnection()\nservable = Component()\n# write!(::AbstractConnection, ::Servable):\nwrite!(fakec, servable)\n\n\n\nfield info\n\nroutes::Dict - A dictionary of routes, usually left empty.\nhttp::SpoofStream - A fake http stream that instead writes output to a string.\nextensions::Dict - A dictionary of extensions, usually empty.\n\n\n\nconstructors\n\nSpoofStream(r::Dict, http::SpoofStream, extensions::Dict)\nSpoofStream()\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#Toolips.SpoofStream","page":"extending toolips","title":"Toolips.SpoofStream","text":"SpoofStream\n\ntext::String\n\nThe SpoofStream allows us to fake a connection by building a SpoofConnection which will write to the SpoofStream.text field whenever write! is called. This is useful for testing, or just writing servables into a string.\n\nexample\n\nstream = SpoofStream()\nwrite(stream, \"hello!\")\nprintln(stream.text)\n\n    hello!\nconn = SpoofConnection()\nservab = Component()\nwrite!(conn, servab)\n\n\n\nfield info\n\ntext::String - The text written to the stream.\n\n\n\nconstructors\n\nSpoofStream()\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#Toolips.route_from_dir","page":"extending toolips","title":"Toolips.route_from_dir","text":"Extensions\n\nroutefromdir(dir::String) -> ::Vector{String}\n\n\n\nRecursively appends filenames for a directory AND all subsequent directories.\n\nexample\n\nx::Vector{String} = route_from_dir(\"mypath\")\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Base.show-Tuple{Base.TTY, Component}","page":"extending toolips","title":"Base.show","text":"Interface\n\nshow(t::Base.TTY, x::Component) -> _\n\n\n\nShows a component as markdown in a terminal.\n\nexample\n\n# In the terminal, elsewhere the component will show as HTML.\nshow(x)\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Base.show-Tuple{Component}","page":"extending toolips","title":"Base.show","text":"Interface\n\nshow(x::Component) -> _\n\n\n\nShows a component as HTML.\n\nexample\n\nshow(x)\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.show_log","page":"extending toolips","title":"Toolips.show_log","text":"Extensions\n\nshow_log(level::Int64, message::String, levels::Dict{Any, Crayon},\n\n            prefix::String, time::Any)\n\n\n\nPrints a log to the screen.\n\nexample\n\nshow_log(1, \"hello!\", levels, \"toolips> \", now()\n\n[2022:05:23:22:01] toolips> hello!\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.@L_str","page":"extending toolips","title":"Toolips.@L_str","text":"Interface\n\nL_str(s::String) -> ::String\n\n\n\nCreates a literal string\n\nexample\n\nx = 5\nL\"dollar_signx\" # pretend dollar_sign is a dollar sign.\n\n\n\n\n\n","category":"macro"},{"location":"developer_api/#Toolips.has_extension-Tuple{Dict, Type}","page":"extending toolips","title":"Toolips.has_extension","text":"Internals\n\nhas_extension(d::Dict, t::Type) -> ::Bool\n\n\n\nChecks if d has an extension of type t.\n\nexample\n\nif has_extension(d, Logger)\n    d[:Logger].log(\"it has a logger, I think.\")\nend\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.argsplit","page":"extending toolips","title":"Toolips.argsplit","text":"Internals\n\nargsplit(args::Vector{AbstractString}) -> ::Dict{Symbol, Any}\n\n\n\nUsed by the getargs method to parse GET arguments into a Dict.\n\nexample\n\nargsplit([\"c=5\", \"b=8\"])\n    Dict(:c => 5, :b => 8)\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Base.string-Tuple{Vector{UInt8}}","page":"extending toolips","title":"Base.string","text":"Internals\n\nstring(r::Vector{UInt8}) -> ::String\n\n\n\nTurns a vector of UInt8s into a string.\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.showchildren","page":"extending toolips","title":"Toolips.showchildren","text":"Internals\n\nshowchildren(x::Component) -> ::String\n\n\n\nGet the children of x as a markdown string.\n\nexample\n\nc = divider(\"example\")\nchild = p(\"mychild\")\npush!(c, child)\ns = showchildren(c)\nprintln(s)\n\"##### children\n|-- mychild\n\n\n\n\n\n","category":"function"},{"location":"toolips_session/#toolips-session-extension","page":"session extension","title":"toolips session extension","text":"","category":"section"},{"location":"toolips_session/","page":"session extension","title":"session extension","text":"The ToolipsSession extension is  loaded into apps by default whenever the new_webapp() method is used to create their files, along with the Files extension from the Toolips core (?(Files)).","category":"page"},{"location":"toolips_session/","page":"session extension","title":"session extension","text":"Modules = [ToolipsSession]","category":"page"},{"location":"toolips_session/#ToolipsSession.ToolipsSession","page":"session extension","title":"ToolipsSession.ToolipsSession","text":"Created in June, 2022 by chifi - an open source software dynasty. by team toolips This software is MIT-licensed.\n\nToolipsSession\n\nExtension for:\n\nToolips This module provides the capability to make web-pages interactive by simply\n\nadding the Session extension to your ServerTemplate before starting. There are also methods contained for modifying Servables.\n\nModule Composition\n\nToolipsSession\n\n\n\n\n\n","category":"module"},{"location":"toolips_session/#ToolipsSession.ComponentModifier","page":"session extension","title":"ToolipsSession.ComponentModifier","text":"ComponentModifier\n\nrootc::Dict\nf::Function\nchanges::Vector{String} The ComponentModifier stores a dictionary of components that can be indexed\n\nusing the Components themselves or their names. Methods push strings to the changes Dict. This is passed as an argument into the function provided to the on functions via the do syntax. Indexing will yield a given Component, setting the index to a pair will modify said component.\n\nexample\n\nroute(\"/\") do c::Connection\n    mydiv = divider(\"mydiv\", align = \"center\")\n    on(c, mydiv, \"click\") do cm::ComponentModifier\n        if cm[mydiv][\"align\"] == \"center\"\n            cm[mydiv] = \"align\" => \"left\"\n        else\n            cm[mydiv] = \"align\" => \"center\"\n        end\n    end\n    write!(c, mydiv)\nend\n\n\n\nconstructors\n\nComponentModifier(html::String)\n\n\n\n\n\n","category":"type"},{"location":"toolips_session/#ToolipsSession.Session","page":"session extension","title":"ToolipsSession.Session","text":"Session\n\ntype::Vector{Symbol}\nf::Function\nactive_routes::Vector{String}\nevents::Dict{String, Pair{String, Function}}\niptable::Dict{String, Dates.DateTime}\ntimeout::Integer Provides session capabilities and full-stack interactivity to a toolips server.\n\nNote that the route you want to be interactive must be in active_routes!\n\nexample\n\nexts = [Session()]\nst = ServerTemplate(extensions = exts)\nserver = st.start()\n\nroute!(server, \"/\") do c::Connection\n    myp = p(\"myp\", text = \"welcome to my site\")\n    on(c, myp, \"click\") do cm::ComponentModifier\n        if cm[myp][:text] == \"welcome to my site\"\n            set_text!(cm, myp, \"unwelcome to my site\")\n        else\n            set_text!(cm, myp, \"welcome to my site\")\n        end\n    end\n    write!(c, myp)\nend\n\n\n\nconstructors\n\nSession(activeroutes::Vector{String} = [\"/\"];         transitionduration::AbstractFloat = 0.5,         transition::String = \"ease-in-out\",         timeout::Integer = 30         )\n\n\n\n\n\n","category":"type"},{"location":"toolips_session/#ToolipsSession.TimedTrigger","page":"session extension","title":"ToolipsSession.TimedTrigger","text":"TimedTrigger\n\ntime::Integer\nf::Function Creates a timer which will post to the function f.\n\nexample\n\nroute(\"/\") do c::Connection\n    myp = p(\"hello\", text = \"wow\")\n    timer = TimedTrigger(5000) do cm::ComponentModifier\n        if cm[myp][:text] == \"wow\"\n            c[:Logger].log(\"wow.\")\n        end\n    end\n    write!(c, myp)\n    write!(c, timer)\nend\n\n\n\nconstructors\n\nTimedTrigger(func::Function, time::Integer)\n\n\n\n\n\n","category":"type"},{"location":"toolips_session/#Base.append!-Tuple{ComponentModifier, Servable, Servable}","page":"session extension","title":"Base.append!","text":"Session Interface\n\nappend!(cm::ComponentModifier, s::Servable, child::Servable) -> _\n\n\n\nAppends child to the servable s.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Base.append!-Tuple{ComponentModifier, String, Servable}","page":"session extension","title":"Base.append!","text":"Session Interface\n\nappend!(cm::ComponentModifier, name::String, child::Servable) -> _\n\n\n\nAppends child to the servable s by name.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Base.getindex-Tuple{ComponentModifier, Component}","page":"session extension","title":"Base.getindex","text":"Session Interface\n\ngetindex(cm::ComponentModifier, s::Component) -> ::Component\n\n\n\nGets the Component s from the ComponentModifier cm.\n\nexample\n\non(c, mydiv, \"click\") do cm::ComponentModifier\n    mydiv = cm[mydiv]\n    mydivalignment = mydiv[\"align\"]\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Base.getindex-Tuple{ComponentModifier, String}","page":"session extension","title":"Base.getindex","text":"Session Interface\n\ngetindex(cm::ComponentModifier, s::String) -> ::Component\n\n\n\nGets the a Component by name from cm.\n\nexample\n\non(c, mydiv, \"click\") do cm::ComponentModifier\n    mydiv = cm[\"mydiv\"]\n    mydivalignment = mydiv[\"align\"]\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Base.getindex-Tuple{Session, AbstractString}","page":"session extension","title":"Base.getindex","text":"Session Interface\n\ngetindex(m::Session, s::AbstractString) -> ::Vector{Pair}\n\n\n\nGets a session's refs by ip.\n\nexample\n\nroute(\"/\") do c::Connection\n    c[:Session][getip(c)]\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Base.setindex!-Tuple{ComponentModifier, Pair, Component}","page":"session extension","title":"Base.setindex!","text":"Session Interface\n\nsetindex!(cm::ComponentModifier, p::Pair, s::Component) -> _\n\n\n\nSets the property from p[1] to p[2] on the served Component s.\n\nexample\n\non(c, mydiv, \"click\") do cm::ComponentModifier\n    if cm[mydiv][\"align\"] == \"center\"\n        cm[mydiv] = \"align\" => \"left\"\n    else\n        cm[mydiv] = \"align\" => \"center\"\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Base.setindex!-Tuple{ComponentModifier, Pair, String}","page":"session extension","title":"Base.setindex!","text":"Session Interface\n\nsetindex!(cm::ComponentModifier, p::Pair, s::String) -> _\n\n\n\nSets the property from p[1] to p[2] on the served with name s.\n\nexample\n\non(c, mydiv, \"click\") do cm::ComponentModifier\n    if cm[\"mydiv\"][\"align\"] == \"center\"\n        cm[\"mydiv\"] = \"align\" => \"left\"\n    else\n        cm[\"mydiv\"] = \"align\" => \"center\"\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.animate!-Tuple{ComponentModifier, Servable, Animation}","page":"session extension","title":"Toolips.animate!","text":"Session Interface\n\nanimate!(cm::ComponentModifier, s::Servable, a::Animation; play::Bool) -> _\n\n\n\nUpdates the servable s's animation with the animation a.\n\nexample\n\ns = divider(\"mydiv\")\na = Animation(\"fade\")\na[:from] = \"opacity\" => \"0%\"\na[:to] = \"opacity\" => \"100%\"\n# where c is the Connection.\non(c, s, \"click\") do cm::ComponentModifier\n    animate!(cm, s, a)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.animate!-Tuple{ComponentModifier, String, Animation}","page":"session extension","title":"Toolips.animate!","text":"Session Interface\n\nanimate!(cm::ComponentModifier, s::String, a::Animation; play::Bool) -> _\n\n\n\nUpdates the servable with name s's animation with the animation a.\n\nexample\n\n``` s = divider(\"mydiv\") a = Animation(\"fade\") a[:from] = \"opacity\" => \"0%\" a[:to] = \"opacity\" => \"100%\"\n\nwhere c is the Connection.\n\non(c, s, \"click\") do cm::ComponentModifier     animate!(cm, s, a) end      ```\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.kill!-Tuple{Connection}","page":"session extension","title":"Toolips.kill!","text":"Session Interface\n\nkill!(c::Connection)\n\n\n\nKills a Connection's saved events.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, Servable, Pair}","page":"session extension","title":"Toolips.style!","text":"Session Interface\n\nstyle!(cm::ComponentModifier, s::Servable, p::Pair) -> _\n\n\n\nStyles the Servable s with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, Servable, Style}","page":"session extension","title":"Toolips.style!","text":"Session Interface\n\nstyle!(cm::ComponentModifier, s::Servable, style::Style) -> _\n\n\n\nChanges the style class of s to the style p. Note – styles must be already written to the Connection prior.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, Servable, Vararg{Pair{String, String}}}","page":"session extension","title":"Toolips.style!","text":"Session Interface\n\nstyle!(cm::ComponentModifier, s::Servable, p::Pair{String, String}) -> _\n\n\n\nStyles the Servable s with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, Servable, Vector{Pair{String, String}}}","page":"session extension","title":"Toolips.style!","text":"Session Interface\n\nstyle!(cm::ComponentModifier, name::String, p::Vector{Pair{String, String}}) -> _\n\n\n\nStyles a Servable by name with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, String, Pair}","page":"session extension","title":"Toolips.style!","text":"Session Interface\n\nstyle!(cm::ComponentModifier, name::String, p::Pair) -> _\n\n\n\nStyles a Servable by name with the properties and values in p.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, String, String}","page":"session extension","title":"Toolips.style!","text":"Session Interface\n\nstyle!(cm::ComponentModifier, name::String, sname::String) -> _\n\n\n\nChanges the style class of a Servable by name to the style p by name. Note – styles must be already written to the Connection prior.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.alert!-Tuple{ComponentModifier, AbstractString}","page":"session extension","title":"ToolipsSession.alert!","text":"Session Interface\n\nalert!(cm::ComponentModifier, s::String) -> _\n\n\n\nSends an alert to the current session.\n\nexample\n\non(c, s, \"click\") do cm::ComponentModifier\n    alert!(cm, \"oh no!\")\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.confirm_redirects!-Tuple{ComponentModifier}","page":"session extension","title":"ToolipsSession.confirm_redirects!","text":"Session Interface\n\nfree_redirects!(cm::ComponentModifier) -> _\n\n\n\nAdds an \"are you sure you want to leave this page... unsaved changes\" pop-up  when trying to leave the page. Can be undone with free_redirects!\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.createcomp-Tuple{Any}","page":"session extension","title":"ToolipsSession.createcomp","text":"Session Internals\n\ncreatecomp(element::Any) -> ::Component\n\n\n\nConverts HTML node into a component, used by htmlcomponent(::String).\n\nexample\n\nrn = firstnode(ro)\nchildren::Dict = Dict()\nfor n in eachelement(rn)\n    comp::Component = createcomp(n)\n    push!(children, comp.name => comp)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.document_linker-Tuple{Connection}","page":"session extension","title":"ToolipsSession.document_linker","text":"Session Internals\n\ndocument_linker(c::Connection) -> _\n\n\n\nServed to /modifier/linker by the Session extension. This is where incoming data is posted to for a response.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.free_redirects!-Tuple{ComponentModifier}","page":"session extension","title":"ToolipsSession.free_redirects!","text":"Session Interface\n\nfree_redirects!(cm::ComponentModifier) -> _\n\n\n\nRemoves the \"are you sure you wish to leave\" box that can be created with confirm_redirects!\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.gen_ref-Tuple{}","page":"session extension","title":"ToolipsSession.gen_ref","text":"Session\n\ngen_ref() -> ::String\n\n\n\nCreates a random string of 16 characters. This is used to map connections to specific events by the session.\n\nexample\n\ngen_ref()\n\"jfuR2wgprielweh3\"\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.get_text-Tuple{ComponentModifier, Component}","page":"session extension","title":"ToolipsSession.get_text","text":"Session Interface\n\nget_text(cm::ComponentModifier, s::Component) -> ::String\n\n\n\nRetrieves the text of a given Component.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.get_text-Tuple{ComponentModifier, String}","page":"session extension","title":"ToolipsSession.get_text","text":"Session Interface\n\nget_text(cm::ComponentModifier, s::String) -> ::String\n\n\n\nRetrieves the text of a given Component by name\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.htmlcomponent-Tuple{String}","page":"session extension","title":"ToolipsSession.htmlcomponent","text":"Session Internals\n\nhtmlcomponent(s::String) -> ::Dict{String, Toolips.Component}\n\n\n\nConverts HTML into a dictionary of components.\n\nexample\n\ns = \"<div id = 'hello' align = 'center'></div>\"\ncomp = htmlcomponent(s)\ncomp[\"hello\"][\"align\"]\n    \"center\"\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, Servable, Pair}","page":"session extension","title":"ToolipsSession.modify!","text":"Session Interface\n\nmodify!(cm::ComponentModifier, s::Servable, p::Pair) -> _\n\n\n\nModifies the key property p[1] to p[2] on s\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, Servable, Vararg{Pair}}","page":"session extension","title":"ToolipsSession.modify!","text":"Session Interface\n\nmodify!(cm::ComponentModifier, s::Servable, p::Pair ...) -> _\n\n\n\nModifies the key properties of p[1] to the value of p[2] on s.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, Servable, Vector{Pair{String, String}}}","page":"session extension","title":"ToolipsSession.modify!","text":"Session Interface\n\nmodify!(cm::ComponentModifier, s::Servable, p::Vector{Pair{String, String}}) -> _\n\n\n\nModifies the key properties of i[1] => i[2] for i in p on s.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, String, Pair}","page":"session extension","title":"ToolipsSession.modify!","text":"Session Interface\n\nmodify!(cm::ComponentModifier, s::Servable, p::Pair) -> _\n\n\n\nModifies the key property p[1] to p[2] on s\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.move!-Tuple{ComponentModifier, Pair{Servable, Servable}}","page":"session extension","title":"ToolipsSession.move!","text":"Session Interface\n\nmove!(cm::ComponentModifier, p::Pair{Servable, Servable}) -> _\n\n\n\nMoves the servable p[2] to be a child of p[1]\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.move!-Tuple{ComponentModifier, Pair{String, String}}","page":"session extension","title":"ToolipsSession.move!","text":"Session Interface\n\nmove!(cm::ComponentModifier, p::Pair{String, String}) -> _\n\n\n\nMoves the servable p[2] to be a child of p[1] by name.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.observe!-Tuple{Function, Connection, Integer}","page":"session extension","title":"ToolipsSession.observe!","text":"Session Interface\n\nobserve!(f::Function, c::Connection, time::Integer) -> _\n\n\n\nCreates a TimedTrigger, and then writes it to the connection.\n\nexample\n\nroute(\"/\") do c::Connection\n    observe!(c, 1000) do cm::ComponentModifier\n        ...\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.on-Tuple{Function, Connection, AbstractString}","page":"session extension","title":"ToolipsSession.on","text":"Session Interface\n\non(f::Function, c::Connection, event::AbstractString)\n\n\n\nCreates a new event for the current IP in a session. Performs the function on     the event. The function should take a ComponentModifier as an argument.\n\nexample\n\nroute(\"/\") do c::Connection\n    myp = p(\"hello\", text = \"wow\")\n    on(c, \"load\") do c::ComponentModifier\n\n    end\n    write!(c, myp)\n    write!(c, timer)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.on-Tuple{Function, Connection, Component, AbstractString}","page":"session extension","title":"ToolipsSession.on","text":"Interface\n\non(f::Function, c::Connection, s::Component, event::AbstractString)\n\n\n\nCreates a new event for the current IP in a session. Performs the function on     the event. The function should take a ComponentModifier as an argument.\n\nexample\n\nroute(\"/\") do c::Connection\n    myp = p(\"hello\", text = \"wow\")\n    timer = TimedTrigger(5000) do cm::ComponentModifier\n        if cm[myp][:text] == \"wow\"\n            c[:Logger].log(\"wow.\")\n        end\n    end\n    write!(c, myp)\n    write!(c, timer)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.on_keydown-Tuple{Function, Connection, String}","page":"session extension","title":"ToolipsSession.on_keydown","text":"Session Interface\n\non_keydown(f::Function, c::Connection, key::AbstractString)\n\n\n\nCreates a new event for the current IP in a session. Performs f when the key     is pressed.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.on_keyup-Tuple{Function, Connection, String}","page":"session extension","title":"ToolipsSession.on_keyup","text":"Session Interface\n\non_keyup(f::Function, c::Connection, key::AbstractString)\n\n\n\nCreates a new event for the current IP in a session. Performs f when the key     is brought up.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.pauseanim!-Tuple{ComponentModifier, Servable}","page":"session extension","title":"ToolipsSession.pauseanim!","text":"Session Interface\n\npauseanim!(cm::ComponentModifier, s::Servable) -> _\n\n\n\nPauses the servable's animation.\n\nexample\n\non(c, s, \"click\") do cm::ComponentModifier\n    pauseanim!(cm, s)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.pauseanim!-Tuple{ComponentModifier, String}","page":"session extension","title":"ToolipsSession.pauseanim!","text":"Session Interface\n\npauseanim!(cm::ComponentModifier, name::String) -> _\n\n\n\nPauses a servable's animation by name.\n\nexample\n\non(c, s, \"click\") do cm::ComponentModifier\n    pauseanim!(cm, s.name)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.playanim!-Tuple{ComponentModifier, Servable}","page":"session extension","title":"ToolipsSession.playanim!","text":"Session Interface\n\nplayanim!(cm::ComponentModifier, s::Servable) -> _\n\n\n\nPlays the servable's animation.\n\nexample\n\non(c, s, \"click\") do cm::ComponentModifier\n    playanim!(cm, s)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.playanim!-Tuple{ComponentModifier, String}","page":"session extension","title":"ToolipsSession.playanim!","text":"Session Interface\n\nplayanim!(cm::ComponentModifier, name::String) -> _\n\n\n\nPlays a servable's animation by name.\n\nexample\n\non(c, s, \"click\") do cm::ComponentModifier\n    playanim!(cm, s.name)\nend\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.redirect!","page":"session extension","title":"ToolipsSession.redirect!","text":"Session Interface\n\nredirect!(cm::ComponentModifier, url::AbstractString, delay::Int64 = 0) -> _\n\n\n\nRedirects the session to url. Can be given delay with delay.\n\nexample\n\n\n\n\n\n\n\n","category":"function"},{"location":"toolips_session/#ToolipsSession.remove!-Tuple{ComponentModifier, Servable}","page":"session extension","title":"ToolipsSession.remove!","text":"Session Interface\n\nremove!(cm::ComponentModifier, s::Servable) -> _\n\n\n\nRemoves the servable s.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.remove!-Tuple{ComponentModifier, String}","page":"session extension","title":"ToolipsSession.remove!","text":"Session Interface\n\nremove!(cm::ComponentModifier, s::String) -> _\n\n\n\nRemoves the servable s by name.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.remove!-Tuple{Connection, AbstractString, Servable}","page":"session extension","title":"ToolipsSession.remove!","text":"Session Interface\n\nremove!(c::Connection, fname::AbstractString, s::Servable) -> _\n\n\n\nRemoves a given function call from a connection's Session.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.set_children!-Tuple{ComponentModifier, Servable, Vector{Servable}}","page":"session extension","title":"ToolipsSession.set_children!","text":"Session Interface\n\nset_children!(cm::ComponentModifier, s::Servable, v::Vector{Servable}) -> _\n\n\n\nSets the children of a given component.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.set_children!-Tuple{ComponentModifier, String, Vector{Servable}}","page":"session extension","title":"ToolipsSession.set_children!","text":"Session Interface\n\nset_children!(cm::ComponentModifier, s::String, v::Vector{Servable}) -> _\n\n\n\nSets the children of a given component by name.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.set_text!-Tuple{ComponentModifier, Servable, String}","page":"session extension","title":"ToolipsSession.set_text!","text":"Session Interface\n\nset_text!(cm::ComponentModifier, s::Servable, txt::String) -> _\n\n\n\nSets the inner HTML of a Servable.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.set_text!-Tuple{ComponentModifier, String, String}","page":"session extension","title":"ToolipsSession.set_text!","text":"Session Interface\n\nset_text!(cm::ComponentModifier, s::String, txt::String) -> _\n\n\n\nSets the inner HTML of a Servable by name\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"#toolips-docs","page":"toolips","title":"toolips docs","text":"","category":"section"},{"location":"#a-manic-web-development-framework","page":"toolips","title":"a manic web-development framework","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Toolips.jl is a reactive. full-stack, modular and extendable web-development framework written in pure Julia.","category":"page"},{"location":"#curated-projects","page":"toolips","title":"curated projects","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Below are some curated and deployed toolips apps and toolips extensions that can be used as examples or loaded as a server extension to look into.","category":"page"},{"location":"#apps","page":"toolips","title":"apps","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"EmsComputer.jl - ems computer\nToolipsApp.jl - toolips app\nPasta.jl","category":"page"},{"location":"#server-extensions","page":"toolips","title":"server extensions","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsSession.jl - Interactive Components\nToolipsRemote.jl - Allows remote management of a Toolips server via a","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"regular HTTP request.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsDefaults.jl - More style components, and style default methods.","category":"page"},{"location":"#servables","page":"toolips","title":"servables","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsDefaults.jl - More style components, and style default methods.","category":"page"},{"location":"#add-your-project!","page":"toolips","title":"add your project!","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Want to see your project here? Open an issue.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"Toolips","category":"page"},{"location":"#Toolips","page":"toolips","title":"Toolips","text":"Created in February, 2022 by chifi - an open source software dynasty. by team toolips This software is MIT-licensed.\n\nToolips\n\nToolips.jl is a fast, asynchronous, low-memory, full-stack, and reactive web-development framework always written in pure Julia.\n\nModule Composition\n\nToolips\n\n\n\n\n\n","category":"module"},{"location":"projects/#projects","page":"projects","title":"projects","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Projects in Toolips are easy to start. You can either choose to create a project directory structure, or optionally; you can create an entire server inside of your REPL!","category":"page"},{"location":"projects/#creating-a-project","page":"projects","title":"creating a project","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects are created using the newapp and newwebapp methods respectively. newapp will create a simple project and newwebapp will create a full-stack web-app.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips.new_app","category":"page"},{"location":"projects/#Toolips.new_app","page":"projects","title":"Toolips.new_app","text":"Core\n\nnew_app(::String) -> _\n\n\n\nCreates a minimalistic app, usually used for creating APIs and endpoints.\n\nexample\n\nusing Toolips\nToolips.new_app(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips.new_webapp","category":"page"},{"location":"projects/#Toolips.new_webapp","page":"projects","title":"Toolips.new_webapp","text":"Core\n\nnew_webapp(::String) -> _\n\n\n\nCreates a fully-featured Toolips web-app. Adds ToolipsSession, ideal for full-stack web-sites.\n\nexample\n\nusing Toolips\nToolips.new_webapp(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"projects/#a-repl-crash-course","page":"projects","title":"a repl crash course","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"After a server is running, Toolips has an interactive level that allows you to introspect and modify server attributes via the WebServer type. If you start a project with new web-app or new-app, then your WebServer type on your new server will automatically become (project-name)Server. For example, a ToolipsTutorial WebServer would be named ToolipsTutorialServer by default. Let's create a new project and get started with the toolips command-line interface.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Toolips\nToolips.new_app(\"MyApp\")\n\njulia> Toolips.new_app(\"MyApp\")\n  Generating  project MyApp:\n    MyApp/Project.toml\n    MyApp/src/MyApp.jl\n....","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now we will cd into our new project directory, and activate dev.jl.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"shell> cd MyApp\n/home/emmac/dev/toolips/MyApp\njulia> include(\"dev.jl\")\n  Activating project at `~/dev/toolips/MyApp`\n[2022:06:19:15:37]: 🌷 toolips> Toolips Server starting on port 8000\n[2022:06:19:15:37]: 🌷 toolips> Successfully started server on port 8000\n[2022:06:19:15:37]: 🌷 toolips> You may visit it now at http://127.0.0.1:8000","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Activating this will give us the new variable MyAppServer. To start, we can view our routes and extensions by using the methods under those same names:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"?(routes(ws::WebServer))\n\njulia> routes(MyAppServer)\nDict{String, Function} with 2 entries:\n  \"404\" => #1\n  \"/\"   => home\n\n  julia> Toolips.extensions(MyAppServer)\n Dict{Symbol, Logger} with 1 entry:\n   :Logger => Logger(:connection, \"/home/emmac/dev/toolips/MyApp/logs/log.txt\", Dict{Any, Crayons.Crayon}(4=>\\e[31;1m, 2=>\\e[93m, :message_crayon=>\\e[94;1m, 3=>\\e[33;1m, 1=>\\e[96m, :time_crayon=>","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can also reroute the server's routes with the route! method:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(MyAppServer, \"/\") do c::Connection\n    c[:Logger].log(\"Wow!\")\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can index extensions with a Symbol, and index routes with a String.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"c[\"/\"]\n    home\nc[:Logger]\n    Logger( .....  )","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Lastly, we can kill the server using kill!","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"kill!(MyAppServer)","category":"page"},{"location":"projects/#project-walkthrough","page":"projects","title":"project walkthrough","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects  work just like any other Julia project. There is no random silliness going on here – no need to source anything with Bash, merely call Julia. After running newapp or newwebapp, you should be greeted with a new directory named after your project name.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Pkg; Pkg.add(\"Toolips\")\nusing Toolips\nToolips.new_webapp(\"ToolipsTutorial\")","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd ToolipsTutorial\n~/dev/ToolipsTutorial\n\ntree .\n[.]\n├── dev.jl\n├── prod.jl\n├── Manifest.toml\n├── Project.toml\n├── [logs]\n│   └── log.txt\n├── [public]\n└── [src]\n    └── ToolipsTutorial.jl\n\n3 directories, 6 files\n","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The directory structure is that of a typical Julia project – albeit with a few extra little files and folders. The source code that creates our websites is contained within the src directory. A Logger comes loaded as a default extension, although we could remove it if we really wanted to, or likewise – create our own Logger and load it as an extension – which is pretty much what makes toolips great. The Logger by default will log to the logs directory. The public directory contains any files we want to be served automatically by the Files ServerExtension. This directory will be missing if you decide to utilize the new_app method. The other two things that are not Julia defaults are the files dev.jl and prod.jl. These are environment files, they store environmental variables to be sourced above the module in Main. Let's take a look:","category":"page"},{"location":"projects/#dev.jl","page":"projects","title":"dev.jl","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"#==\ndev.jl is an environment file. This file loads and starts servers, and\ndefines environmental variables, setting the scope a lexical step higher\nwith modularity.\n==#\nusing Pkg; Pkg.activate(\".\")\nusing Toolips\nusing Revise\nusing ToolipsModifier\nusing ToolipsTutorial\n\nIP = \"127.0.0.1\"\nPORT = 8000\n#==\nExtension description\n:logger -> Logs messages into both a file folder and the terminal.\n:public -> Routes the files from the public directory.\n:mod -> ToolipsModifier; allows us to make Servables reactive. See ?(on)\n==#\nextensions = Dict(:logger => Logger(), :public => Files(\"public\"),\n:mod => Modifier())\nToolipsTutorialServer = ToolipsTutorial.start(IP, PORT, extensions)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Firstly, dev.jl activates the project environment with Pkg. Next, we load all of the dependencies. The first one is the most obvious; you are reading the documentation for it. The second one is Revise. Revise.jl allows us to update our modules while they are loaded into main. This just makes rerouting easier, as you can modify the text file, save it, update the routes, and then your new website is up with no downtime. No worries, I will be showing how this is done in no time. First though, we will also consider the extensions section. I have been kind enough to leave a little note here,","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Extension description\n:logger -> Logs messages into both a file folder and the terminal.\n:public -> Routes the files from the public directory.\n:mod -> ToolipsModifier; allows us to make Servables reactive. See ?(on)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"This describes what each extension does. Of course, all the effort it takes to add more is merely adding them via Pkg and adding them to this dictionary. We are going to include this file in order to start the server. We would include prod.jl if we wanted to start a production server, which is a very similar file in content, jut missing the Revise.jl First, let us take a look at the source file.","category":"page"},{"location":"projects/#src.jl","page":"projects","title":"src.jl","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"module ToolipsTutorial\nusing Toolips\nusing ToolipsModifier\n\nfunction home(c::Connection)\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\nend\n\nfourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend\n\n\"\"\"\nstart()\n\"\"\"\nfunction start(IP::String = \"127.0.0.1\", PORT::Integer = 8000,\n    extensions::Dict = Dict(:logger => Logger()))\n    rs = routes(route(\"/\", home), fourofour)\n    server = ServerTemplate(IP, PORT, rs, extensions = extensions)\n    server.start()\nend\n\nend # - module","category":"page"},{"location":"projects/#start","page":"projects","title":"start","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"This file will likely look a bit different in the future, with a bit more documentation, and maybe a more illustrious default project, but do not fret – the names will all be the same and the file similar enough! The start function is probably the most important here. This function constructs our Routes, makes a ServerTemplate and then runs ServerTemplate.start(), returning a WebServer. Back up in dev.jl we see that this is aptly named \"projectnameServer\"","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"extensions = Dict(:logger => Logger(), :public => Files(\"public\"),\n:mod => Modifier())\nToolipsTutorialServer = ToolipsTutorial.start(IP, PORT, extensions)","category":"page"},{"location":"projects/#home","page":"projects","title":"home","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"function home(c::Connection)\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The home function is a function built to be routed to. We can tell this is the ] case because it takes a Connection as its only argument. This is one method of making a route. Inside the function, c is written to using the write! method. Keep this method in mind, as we will be using it a lot; it is the primary output for toolips. There is also a component constructed via the p() method. This just creates a p. The id of the p will be its name, \"helloworld\", and the text; which modifies the inner text of a given element. The other special key is :children, which is of type Vector{Servable}. This will be any children to write to the stream inside of this tag. Children are usually added via the push!(::Servable, ::Servable) method.","category":"page"},{"location":"projects/#fourofour","page":"projects","title":"fourofour","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"fourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The fourofour is made as a global variable of type Route, rather than as a function.","category":"page"},{"location":"projects/#command-line-interface","page":"projects","title":"command line interface","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"We have a few different options when it comes to starting the server. These options of course come with all toolips servers. The first of which is to load a server as a module. Most modular servers will use the Module.start() method, just like our project ToolipsTutorial does above. This is ideal if","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You want to try someone else's Toolips Application.\nThe module you are working with is an Application.\nThe module you are working with is an extension; then the module is used","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"inside of another project, just to be clear.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Pkg\nPkg.add(url = \"https://github.com/ChifiSource/ToolipsApp.jl\")\nusing ToolipsApp\nToolipsAppServer = ToolipsApp.start()","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Alternatively, we can always git clone the repository, or with a project we started serve our project. This is ideal if","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You want to put the server into production.\nYou want to develop the project. \n","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can start the server in this way by utilizing the environment files discussed before. This is done either via the include(\"\") method in the REPL, or via the -L parameter in Bash.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"pwd()\n\"~/dev/ToolipsTutorial\"\ninclude(\"dev.jl\")\n#==\n[ Info: Precompiling ToolipsTutorial [9dd80660-3bd1-4940-be1d-3a5faeb076a0]\n[2022-06-14T18:50:45.970]: Toolips Server starting on port 8000\n[2022-06-14T18:50:46.521]: Successfully started server on port 8000\n[2022-06-14T18:50:46.966]: You may visit it now at http://127.0.0.1:8000\n==#","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"julia -L dev.jl\n[ Info: Precompiling ToolipsTutorial [9dd80660-3bd1-4940-be1d-3a5faeb076a0]\n[2022-06-14T18:50:45.970]: Toolips Server starting on port 8000\n[2022-06-14T18:50:46.521]: Successfully started server on port 8000\n[2022-06-14T18:50:46.966]: You may visit it now at http://127.0.0.1:8000","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Wow now you can see the exact date and time at which I did that, cool. Anyway, with our new toolips server running, we can introspect its routes:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"ToolipsTutorialServer.routes\nDict{String, Function} with 3 entries:\n  \"404\"              => #1\n  \"/\"                => home\n  \"/modifier/linker\" => document_linker\n  julia> typeof(ToolipsTutorialServer)\n  WebServer","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The /modifier/linker route is provided to us by our Modifier extension. We also see that the type of this new variable is WebServer. Viewing the server in the web-browser yields us a small p with a label \"hello world!\". We can also route the server using the route! method, or access extensions and routes by indexing. This is the same way we would use the route() function as is done in our source file. We access Connection extensions by indexing a Connection with a Symbol. We can also access and change routes by indexing with a String. This same methodology is also applied to the WebServer, so we can index it in the same way, as well.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(ToolipsTutorialServer, \"/cupcakes\") do c::Connection\n    write!(c, \"emmy LOVES CUPCAAAKES\")\n    c[:logger].log(1, \"hello\")\nend\n\n[2022-06-14T19:29:32.180]: hello\n\"emmy LOVES CUPCAAAKES\"","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Let's develop our emmy loves cupcakes app a bit further, by instead making it our project route function. Don't close up the REPL, though! we will still be using it!","category":"page"},{"location":"projects/#making-applications","page":"projects","title":"making applications","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Lets return to our project source file,","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"function home(c::Connection)\n    redclass = Style(\"redtxt\", color = \"red\")\n    blueclass = Style(\"bluetxt\", color = \"lightblue\")\n    heading = h(\"cupkakes\", 1, text = \"Cupcakes\")\n    write!(c, p(\"clicktod\",\n    text = \"click to make the heading change color; double click to send to red.\"))\n    write!(c, components(redclass, blueclass))\n    on(c, heading, \"click\") do cm::ComponentModifier\n        style!(cm, heading, blueclass)\n    end\n    on(c, heading, \"dblclick\") do cm::ComponentModifier\n        style!(cm, heading, redclass)\n    end\n    write!(c, heading)\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Here I added an on() method call. This method call allows us to modify components on events. In this example, clicking will make the heading invisible. It is incredibly easy, but incredibly possible! The last step is going to be running the route! method on our WebServer.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(ToolipsTutorialServer, \"/\", ToolipsTutorial.home)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now, we can finally visit; and click to change the color! Hopefully this little overview got you both familiar with Toolips projects, as well as reactivity. If you would like to try this project out for yourself, here is a link to the source.","category":"page"},{"location":"projects/#deploying-a-toolips-server","page":"projects","title":"deploying a toolips server","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects can very easily be deployed with SSL. This overview will demonstrate an example of deploying a non-containerized Toolips.jl project with NGINX. This is because this is likely the most interpretable overview to carry into deploying any project. We will be deploying toolips app with SSL on my server.","category":"page"},{"location":"projects/#tech-stack","page":"projects","title":"tech stack","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Julia 1.7.2\nToolips.jl 0.1.0\nNGINX nginx/1.18.0 (Ubuntu)\nUbuntu 22.04 LTS (GNU/Linux 5.15.0-37-generic x86_64)\nSupervisord 4.2.1","category":"page"},{"location":"projects/#proxy-pass","page":"projects","title":"proxy pass","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"The first thing we are going to need to do is create our server configuration for nginx. This will involve listening on port 80 and     then forwarding any incoming connections to the port of our server. This also assumes that your domain or IP has already been routed to your DNS and under normal circumstances your domain or IP would be servable. We will go ahead and ssh into our server:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"ssh emmac@xx.xxx.xxx","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"If you do not have nginx, we are going to need it.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"sudo apt install nginx","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now we need to make our nginx server configuration. This is done by creating a new configuration file at the path /etc/nginx/conf.d","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd /etc/nginx/conf.d\nnano toolipsapp.conf","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now we will add a new server, and create a proxy pass.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"server {\n    server_name toolips.app;\n\n    location / {\n        proxy_pass http://127.0.0.1:8001;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Next, reload your configuration","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"nginx -s reload","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"I proxy pass this to http://127.0.0.1:8001. Now lets get our project files setup. We have the choice with toolips to use the project as both a module and a file path. In most cases, when deploying you are probably going to want to have access to the local files of a toolips application, so we are going to do the latter. In order to do so, the first step is to clone the module to our machine with git or scp it over. I like to put mine into the directory /var/www , but this is a matter of personal preference. Now that we have our project in its folder at /var/www, we can create a supervisor configuration. Supervisor allows us to run the application without actually being behind the terminal. However, it is also a pretty good idea to go ahead and test the server before starting your supervisor. So cd to your directory and include dev.jl. Try and visit your domain, and if it is not serving then you know something is likely wrong with either your DNS or nginx configuration. When you are ready to configure your supervisor, the configuration files are in /etc/supervisor/conf.d","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd /etc/supervisor/conf.d\nnano","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You'll want to use the -L argument to start Julia with, this will automatically load the file and begin a new Julia session.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"[program:toolipsapp]\ndirectory=/var/www/ToolipsApp.jl\ncommand=/opt/julia-1.7.3/bin/julia -L prod.jl\nautostart=true\nautorestart=true\nstopasgroup=true\nkillasgroup=true","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Finally, we need to reload supervisor.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"service supervisor reload","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"And if all is well, your server should be up and ready to go!","category":"page"}]
}
